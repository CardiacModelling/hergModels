--- ./doc/conf.py	(original)
+++ ./doc/conf.py	(refactored)
@@ -46,8 +46,8 @@
 master_doc = 'index'
 
 # General information about the project.
-project = u'Myokit'
-copyright = u'2011-present, Michael Clerx'
+project = 'Myokit'
+copyright = '2011-present, Michael Clerx'
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
@@ -185,7 +185,7 @@
 # Grouping the document tree into LaTeX files. List of tuples
 # (source start file, target name, title, author, documentclass[howto/manual]).
 latex_documents = [(
-    'index', 'Myokit.tex', u'Myokit Documentation', u'Michael Clerx', 'manual'
+    'index', 'Myokit.tex', 'Myokit Documentation', 'Michael Clerx', 'manual'
 ), ]
 
 # The name of an image file (relative to this directory) to place at the top of
@@ -217,5 +217,5 @@
 # One entry per manual page. List of tuples
 # (source start file, name, description, authors, manual section).
 man_pages = [(
-    'index', 'myokit', u'Myokit Documentation', [u'Michael Clerx'], 1
+    'index', 'myokit', 'Myokit Documentation', ['Michael Clerx'], 1
 )]
--- ./myokit/_config.py	(original)
+++ ./myokit/_config.py	(refactored)
@@ -7,7 +7,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import print_function
+
 # Load Myokit, at least, the bit that's been setup so far. This just means
 # this method will add a link to the myokit module already being loaded
 # into this method's namespace. This allows us to use the constants defined
@@ -16,7 +16,7 @@
 # Load libraries
 import os
 import platform
-import ConfigParser
+import configparser
 
 
 def _create(path):
@@ -27,7 +27,7 @@
     # Get operating system
     system = platform.system()
     # Create config parser
-    config = ConfigParser.ConfigParser(allow_no_value=True)
+    config = configparser.ConfigParser(allow_no_value=True)
     # Make the parser case sensitive (need for unix paths!)
     config.optionxform = str
     # General information
@@ -163,7 +163,7 @@
     if not os.path.isfile(path):
         _create(path)
     # Create the config parser (no value allows comments)
-    config = ConfigParser.ConfigParser(allow_no_value=True)
+    config = configparser.ConfigParser(allow_no_value=True)
     # Make the parser case sensitive (need for unix paths!)
     config.optionxform = str
     # Parse the config file
--- ./myokit/__init__.py	(original)
+++ ./myokit/__init__.py	(refactored)
@@ -26,7 +26,7 @@
 # matplotlib backend to use. If the user requires a different backend, this
 # will generate an error.
 #
-from __future__ import print_function
+
 # Check python version
 import sys
 if sys.hexversion < 0x02070000:
@@ -162,7 +162,7 @@
 # Location of the OpenCL header files (.h)
 OPENCL_INC = []
 # Load settings
-import _config
+from . import _config
 del(_config)
 # Myokit version
 def version(raw=False):
@@ -276,9 +276,9 @@
 # This allows these modules to be used after myokit was imported, without
 # importing the modules specifically (like os and os.path).
 # All modules imported here must report so in their docs
-import mxml
-import pacing
-import units # Also loads all common unit names
+from . import mxml
+from . import pacing
+from . import units # Also loads all common unit names
 # Globally shared progress reporter
 _Simulation_progress = None
 # Default mmt file parts
--- ./myokit/_aux.py	(original)
+++ ./myokit/_aux.py	(refactored)
@@ -17,7 +17,7 @@
 import fnmatch
 import zipfile
 import tempfile
-from cStringIO import StringIO
+from io import StringIO
 import myokit
 
 # Globally shared numpy expression writer
@@ -356,8 +356,8 @@
     string.
     """
     out = []
-    n = max([len(str(k)) for k in d.iterkeys()])
-    for k, v in d.iteritems():
+    n = max([len(str(k)) for k in d.keys()])
+    for k, v in d.items():
         k = str(k)
         out.append(k + ' ' * (n - len(k)) + ' = ' + strfloat(v))
     return '\n'.join(out)
@@ -522,7 +522,7 @@
         return lvsd(s2, s1)
     if not s1:
         return len(s2)
-    previous_row = xrange(len(s2) + 1)
+    previous_row = range(len(s2) + 1)
     for i, c1 in enumerate(s1):
         current_row = [i + 1]
         for j, c2 in enumerate(s2):
@@ -553,8 +553,8 @@
         # Compare models
         if live:
             print('Comparing:')
-            print('  [1] ' + model1.name())
-            print('  [2] ' + model2.name())
+            print(('  [1] ' + model1.name()))
+            print(('  [2] ' + model2.name()))
         # -> Model meta data
         self._meta(model1, model2)
         # -> User functions
@@ -567,7 +567,7 @@
         self._components(model1, model2)
         if live:
             print('Done')
-            print('  ' + str(len(self._diff)) + ' differences found')
+            print(('  ' + str(len(self._diff)) + ' differences found'))
 
     def _components(self, m1, m2):
         """
@@ -641,7 +641,7 @@
         else:
             name = ' in <' + x1.qname() + '>'
         seen = set()
-        for key, value in x1.meta.iteritems():
+        for key, value in x1.meta.items():
             seen.add(key)
             try:
                 if value != x2.meta[key]:
@@ -652,7 +652,7 @@
                 self._write(
                     '[2] Missing Meta property' + name + ': "' + str(key)
                     + '"')
-        for key, value in x2.meta.iteritems():
+        for key, value in x2.meta.items():
             if key not in seen:
                 self._write(
                     '[1] Missing Meta property' + name + ': "' + str(key)
@@ -668,7 +668,7 @@
         c2 = m2.state()
         for k, v1 in enumerate(s1):
             try:
-                v2 = s2.next()
+                v2 = next(s2)
             except StopIteration:
                 self._write('[2] Missing state at position ' + str(k))
                 continue
@@ -714,14 +714,14 @@
         u1 = m1.user_functions()
         u2 = m2.user_functions()
         seen = set()
-        for name, func in u1.iteritems():
+        for name, func in u1.items():
             seen.append(name)
             try:
                 if func != u2[name]:
                     self._write('[x] Mismatched User function <' + name + '>')
             except KeyError:
                 self._write('[2] Missing User function <' + name + '>')
-        for name, func in u2.iteritems():
+        for name, func in u2.items():
             if name not in seen:
                 self._write('[1] Missing User function <' + name + '>.')
 
@@ -774,7 +774,7 @@
     """
     global _numpywriter_
     if _numpywriter_ is None:
-        from formats.python import NumpyExpressionWriter
+        from .formats.python import NumpyExpressionWriter
         _numpywriter_ = NumpyExpressionWriter()
 
         def name(x):
@@ -882,7 +882,7 @@
     """
     global _pywriter_
     if _pywriter_ is None:
-        from formats.python import PythonExpressionWriter
+        from .formats.python import PythonExpressionWriter
         _pywriter_ = PythonExpressionWriter()
 
         def name(x):
@@ -974,7 +974,7 @@
                     'get_model': get_model,
                     'get_protocol': get_protocol,
                 }
-                exec self.script in environment
+                exec(self.script, environment)
             except Exception:
                 self.exc_info = sys.exc_info()
             finally:
@@ -987,7 +987,7 @@
     r = Runner(model, protocol, script, stdout, stderr, progress)
     r.run()
     if r.exc_info is not None:
-        raise r.exc_info[0], r.exc_info[1], r.exc_info[2]
+        raise r.exc_info[0](r.exc_info[1]).with_traceback(r.exc_info[2])
 
     # Free some space
     del(r)
@@ -1241,7 +1241,7 @@
     """
     Turns the given number into a string, without losing accuracy.
     """
-    if type(number) in [str, unicode]:
+    if type(number) in [str, str]:
         return number
     if isinstance(number, myokit.Number):
         number = number.eval()
--- ./myokit/_datablock.py	(original)
+++ ./myokit/_datablock.py	(refactored)
@@ -6,7 +6,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import division
+
 import os
 import sys
 import array
@@ -134,10 +134,10 @@
         Returns a :class:`myokit.DataBlock2d` based on this 1d data block.
         """
         b = DataBlock2d(self._nx, 1, self._time)
-        for k, v in self._0d.iteritems():
+        for k, v in self._0d.items():
             b.set0d(k, v)
         shape = (self._nt, 1, self._nx)
-        for k, v in self._1d.iteritems():
+        for k, v in self._1d.items():
             b.set2d(k, v.reshape(shape))
         return b
 
@@ -189,7 +189,7 @@
         # Find first activation time
         have_crossing = False
         t = []
-        for i in xrange(ilo, ihi):
+        for i in range(ilo, ihi):
             v = v_series[i]
             # Get indice of first threshold crossing with positive flank
             # Don't include crossings at log indice 0
@@ -241,7 +241,7 @@
             raise ValueError('The given time variable should be 0d.')
         # Check if everything is 0d or 1d, get size
         size = None
-        for name, info in infos.iteritems():
+        for name, info in infos.items():
             d = info.dimension()
             if d not in (0, 1):
                 raise ValueError(
@@ -260,7 +260,7 @@
         nx = size[0]
         # Create data block
         block = DataBlock1d(nx, log[time], copy=True)
-        for name, info in infos.iteritems():
+        for name, info in infos.items():
             if info.dimension() == 0:
                 # Add 0d time series
                 if name == time:
@@ -477,19 +477,19 @@
                 iprogress = 0
                 progress.update(iprogress * fraction)
             head = iter(head)
-            nt = int(head.next())
-            nx = int(head.next())
-            dtype = str(head.next())[1:-1]
+            nt = int(next(head))
+            nx = int(next(head))
+            dtype = str(next(head))[1:-1]
             if dtype not in dsize:
                 raise myokit.DataBlockReadError(
                     'Unable to read DataBlock1d: unrecognized data type "'
                     + str(dtype) + '".')
             names_0d = []
             names_1d = []
-            name = head.next()
+            name = next(head)
             while name != '1':
                 names_0d.append(name[1:-1])
-                name = head.next()
+                name = next(head)
             for name in head:
                 names_1d.append(name[1:-1])
             del(head)
@@ -607,9 +607,9 @@
         n = self._nt * self._nx
         body_str = []
         body_str.append(array.array(dtype, self._time))
-        for name, data in self._0d.iteritems():
+        for name, data in self._0d.items():
             body_str.append(array.array(dtype, data))
-        for name, data in self._1d.iteritems():
+        for name, data in self._1d.items():
             body_str.append(array.array(dtype, data.reshape(n, order='C')))
         if sys.byteorder == 'big':
             for ar in body_str:
@@ -856,7 +856,7 @@
         block = DataBlock2d(nx, ny, time, copy=True)
         # Enter 0d data
         if map0d:
-            for name, old in map0d.iteritems():
+            for name, old in map0d.items():
                 if old[0] is None:
                     b = block2
                     n = old[1]
@@ -870,7 +870,7 @@
                         ' be None.')
                 block.set0d(name, b.get0d(n))
         # Enter 2d data
-        for name, source in map2d.iteritems():
+        for name, source in map2d.items():
             # Get data sources
             name1, name2 = source[0], source[1]
             source1 = block1.get2d(name1)
@@ -911,7 +911,7 @@
                 'Eigenvalues can only be determined for square data blocks.')
         data = self._2d[name]
         dominants = []
-        for t in xrange(self._nt):
+        for t in range(self._nt):
             e = np.linalg.eigvals(data[t])
             dominants.append(e[np.argmax(np.absolute(e))])
         return np.array(dominants)
@@ -930,7 +930,7 @@
                 'Eigenvalues can only be determined for square data blocks.')
         data = self._2d[name]
         eigenvalues = []
-        for t in xrange(self._nt):
+        for t in range(self._nt):
             eigenvalues.append(np.linalg.eigvals(data[t]))
         return np.array(eigenvalues)
 
@@ -952,7 +952,7 @@
             raise ValueError('The given time variable should be 0d.')
         # Check if everything is 0d or 2d, get size
         size = None
-        for name, info in infos.iteritems():
+        for name, info in infos.items():
             d = info.dimension()
             if d not in (0, 2):
                 raise ValueError(
@@ -971,7 +971,7 @@
         nx, ny = size
         # Create data block
         block = DataBlock2d(nx, ny, log[time], copy=True)
-        for name, info in infos.iteritems():
+        for name, info in infos.items():
             if info.dimension() == 0:
                 # Add 0d time series
                 if name == time:
@@ -1037,7 +1037,7 @@
         stored in this block. The given values are references! No copy of the
         data is made.
         """
-        return self._2d.iteritems()
+        return iter(self._2d.items())
 
     def items2d(self):
         """
@@ -1045,7 +1045,7 @@
         stored in this block. The given values are references! No copy of the
         data is made.
         """
-        return self._2d.iteritems()
+        return iter(self._2d.items())
 
     def keys0d(self):
         """
@@ -1075,7 +1075,7 @@
                 'Eigenvalues can only be determined for square data blocks.')
         data = self._2d[name]
         largest = []
-        for t in xrange(self._nt):
+        for t in range(self._nt):
             e = np.linalg.eigvals(data[t])
             largest.append(e[np.argmax(np.real(e))])
         return np.array(largest)
@@ -1172,20 +1172,20 @@
                 iprogress = 0
                 progress.update(iprogress * fraction)
             head = iter(head)
-            nt = int(head.next())
-            ny = int(head.next())
-            nx = int(head.next())
-            dtype = str(head.next())[1:-1]
+            nt = int(next(head))
+            ny = int(next(head))
+            nx = int(next(head))
+            dtype = str(next(head))[1:-1]
             if dtype not in dsize:
                 raise myokit.DataBlockReadError(
                     'Unable to read DataBlock2d: unrecognized data type "'
                     + str(dtype) + '".')
             names_0d = []
             names_2d = []
-            name = head.next()
+            name = next(head)
             while name != '2':
                 names_0d.append(name[1:-1])
-                name = head.next()
+                name = next(head)
             for name in head:
                 names_2d.append(name[1:-1])
             del(head)
@@ -1306,9 +1306,9 @@
         n = self._nt * self._ny * self._nx
         body_str = []
         body_str.append(array.array(dtype, self._time))
-        for name, data in self._0d.iteritems():
+        for name, data in self._0d.items():
             body_str.append(array.array(dtype, data))
-        for name, data in self._2d.iteritems():
+        for name, data in self._2d.items():
             body_str.append(array.array(dtype, data.reshape(n, order='C')))
         if sys.byteorder == 'big':
             for ar in body_str:
@@ -1449,7 +1449,7 @@
         super(ColorMapMeta, cls).__init__(name, bases, dct)
 
 
-class ColorMap(object):
+class ColorMap(object, metaclass=ColorMapMeta):
     """
     *Abstract class*
 
@@ -1484,7 +1484,6 @@
     three) bytes describe the first float, the next four (or three) describe
     the second float and so on.
     """
-    __metaclass__ = ColorMapMeta
 
     def __call__(floats, lower=None, upper=None, alpha=True, rgb=None):
         raise NotImplementedError
@@ -1556,7 +1555,7 @@
         """
         Returns an iterator over the names of all available colormaps.
         """
-        return ColorMap._colormaps.iterkeys()
+        return iter(ColorMap._colormaps.keys())
 
     @staticmethod
     def normalize(floats, lower=None, upper=None):
--- ./myokit/_datalog.py	(original)
+++ ./myokit/_datalog.py	(refactored)
@@ -197,10 +197,10 @@
         log = DataLog()
         log._time = self._time
         if numpy:
-            for k, v in self.iteritems():
+            for k, v in self.items():
                 log[str(k)] = np.array(v, copy=True, dtype=float)
         else:
-            for k, v in self.iteritems():
+            for k, v in self.items():
                 log[str(k)] = list(v)
         return log
 
@@ -228,7 +228,7 @@
         log = DataLog()
         log._time = self._time
         # Add data
-        for k, v1 in self.iteritems():
+        for k, v1 in self.items():
             v2 = other[k]
             if isinstance(v1, np.ndarray) or isinstance(v2, np.ndarray):
                 # Concatenation copies data
@@ -294,7 +294,7 @@
         out._time = self._time
         out[self._time] = logs[0][self._time]
         for i, log in enumerate(logs):
-            for k, v in log.iteritems():
+            for k, v in log.items():
                 if k != self._time:
                     out[k, i] = v
         return out
@@ -307,7 +307,7 @@
         Returns True if one of the variables in this DataLog has a ``NaN`` as
         its final logged value.
         """
-        for k, d in self.iteritems():
+        for k, d in self.items():
             if len(d) > 0 and np.isnan(d[-1]):
                 return True
         return False
@@ -361,7 +361,7 @@
         log2 = DataLog()
         log1._time = self._time
         log2._time = self._time
-        for k, v in self.iteritems():
+        for k, v in self.items():
             if isinstance(v, np.ndarray):
                 log1[k] = np.array(v[:i], copy=True, dtype=float)
                 log2[k] = np.array(v[i:], copy=True, dtype=float)
@@ -378,7 +378,7 @@
         """
         log = DataLog()
         log._time = self._time
-        for k, v in self.iteritems():
+        for k, v in self.items():
             if isinstance(v, np.ndarray):
                 log[k] = np.array(v[a:b], copy=True, dtype=float)
             else:
@@ -392,7 +392,7 @@
         """
         log = DataLog()
         log._time = self._time
-        for k, v in self.iteritems():
+        for k, v in self.items():
             if isinstance(v, np.ndarray):
                 log[k] = np.array(v[i:], copy=True, dtype=float)
             else:
@@ -406,7 +406,7 @@
         """
         log = DataLog()
         log._time = self._time
-        for k, v in self.iteritems():
+        for k, v in self.items():
             if isinstance(v, np.ndarray):
                 log[k] = np.array(v[:i], copy=True, dtype=float)
             else:
@@ -422,7 +422,7 @@
         ``['0.membrane.V', '1.membrane.V', '2.membrane,V', ...]``, or
         ``['0.0.membrane.V', '0.1.membrane.V', '1.0.membrane,V', ...]``.
         """
-        keys = [x for x in self.iterkeys() if x.endswith('.' + str(query))]
+        keys = [x for x in self.keys() if x.endswith('.' + str(query))]
         keys.sort()
         return keys
 
@@ -433,7 +433,7 @@
         """
         if len(self) == 0:
             return 0
-        return len(self.itervalues().next())
+        return len(next(iter(self.values())))
 
     @staticmethod
     def load(filename, progress=None, msg='Loading DataLog'):
@@ -507,7 +507,7 @@
                 return log
             head = iter(head)
             # Skip first line
-            head.next()
+            next(head)
             # Get field information, data type and size is given redundantly
             fields = []
             for line in head:
@@ -519,10 +519,10 @@
             # Parse header in new format:
             # Number of fields, length of data arrays, data type, time, fields
             head = iter(head.splitlines())
-            n = int(head.next())
-            data_size = int(head.next())
-            data_type = head.next()
-            time = head.next()
+            n = int(next(head))
+            data_size = int(next(head))
+            data_type = next(head)
+            time = next(head)
             if time:
                 # Note, this field doesn't have to be present in the log!
                 log._time = time
@@ -622,7 +622,7 @@
             # Get enumerated iterator over characters
             line = enumerate(line)
             try:
-                i, c = line.next()
+                i, c = next(line)
             except StopIteration:
                 # Empty line
                 return log
@@ -635,7 +635,7 @@
                 # Skip whitespace
                 try:
                     while c in whitespace:
-                        i, c = line.next()
+                        i, c = next(line)
                 except StopIteration:
                     break
                 if c == quote:
@@ -643,13 +643,13 @@
                     run2 = True
                     while run2:
                         try:
-                            i, c = line.next()
+                            i, c = next(line)
                         except StopIteration:
                             e(1, i, 'Unexpected end-of-line inside quoted'
                                 ' string.')
                         if c == quote:
                             try:
-                                i, c = line.next()
+                                i, c = next(line)
                                 if c == quote:
                                     text.append(quote)
                                 elif c == delim or c in whitespace:
@@ -666,14 +666,14 @@
                     while run1 and c != delim:
                         try:
                             text.append(c)
-                            i, c = line.next()
+                            i, c = next(line)
                         except StopIteration:
                             run1 = False
                 # Append new field to list
                 keys.append(''.join(text))
                 # Read next character
                 try:
-                    i, c = line.next()
+                    i, c = next(line)
                 except StopIteration:
                     run1 = False
             if c == delim:
@@ -727,7 +727,7 @@
         """
         log = DataLog()
         log._time = self._time
-        for k, v in self.iteritems():
+        for k, v in self.items():
             log[k] = np.asarray(v)
         return log
 
@@ -806,7 +806,7 @@
         out._time = self._time
         out[self._time] = rtime
         time_part = time[imin:imax]
-        for key, data in self.iteritems():
+        for key, data in self.items():
             if key != self._time:
                 s = Spline(time_part, data[imin:imax], k=1, s=0)
                 out[key] = s(rtime)
@@ -847,12 +847,12 @@
         body_str = []
         # Number of fields, length of data arrays, data type, time, fields
         head_str.append(str(len(self)))
-        head_str.append(str(len(self.itervalues().next())))
+        head_str.append(str(len(next(iter(self.values())))))
         head_str.append(dtype)
         # Note: the time field might not be present in the log!
         head_str.append(self._time if self._time else '')
         # Write field names and data
-        for k, v in self.iteritems():
+        for k, v in self.items():
             head_str.append(k)
             # Create array, ensure it's litte-endian
             ar = array.array(dtype, v)
@@ -942,7 +942,7 @@
         with open(filename, 'wb') as f:
             # Convert dict structure to ordered sequences
             if order:
-                if set(order) != set(self.iterkeys()):
+                if set(order) != set(self.keys()):
                     raise ValueError(
                         'The given `order` sequence must contain all the same'
                         ' keys present in the log.')
@@ -951,17 +951,17 @@
             else:
                 keys = []
                 data = []
-                if self._time and self._time in self.keys():
+                if self._time and self._time in list(self.keys()):
                     # Save time as first variable
                     dat = self[self._time]
                     keys.append(self._time)
                     data.append(dat)
-                    for key, dat in sorted(self.iteritems()):
+                    for key, dat in sorted(self.items()):
                         if key != self._time:
                             keys.append(key)
                             data.append(dat)
                 else:
-                    for key, dat in sorted(self.iteritems()):
+                    for key, dat in sorted(self.items()):
                         keys.append(key)
                         data.append(dat)
             # Number of entries
@@ -979,10 +979,10 @@
                 f.write(delimiter.join(line) + eol)
             # Write data
             data = [iter(x) for x in data]
-            for i in xrange(0, n):
+            for i in range(0, n):
                 line = []
                 for d in data:
-                    line.append(fmat(d.next()))
+                    line.append(fmat(next(d)))
                 f.write(delimiter.join(line) + eol)
 
     def set_time_key(self, key):
@@ -1050,7 +1050,7 @@
                 k += 1
         # Create logs
         logs = []
-        for i in xrange(0, nlogs - 1):
+        for i in range(0, nlogs - 1):
             log = DataLog()
             log._time = self._time
             # Get indices
@@ -1060,7 +1060,7 @@
             if closed_intervals and time[imax] == tstarts[i + 1]:
                 imax += 1
             # Select sections of log and append
-            for k, v in self.iteritems():
+            for k, v in self.items():
                 d = self[k][imin:imax]
                 # Numpy? Then copy data
                 if isinstance(d, np.ndarray):
@@ -1076,7 +1076,7 @@
         if not closed_intervals and time[-1] >= tmin + nlogs * period:
             imax -= 1
         # Select sections of log and append
-        for k, v in self.iteritems():
+        for k, v in self.items():
             d = self[k][imin:imax]
             # Numpy? Then copy data
             if isinstance(d, np.ndarray):
@@ -1093,7 +1093,7 @@
                 for k, log in enumerate(logs):
                     tlist = log[self._time]
                     tdiff = k * period
-                    for i in xrange(len(tlist)):
+                    for i in range(len(tlist)):
                         tlist[i] -= tdiff
         return logs
 
@@ -1177,7 +1177,7 @@
                 raise myokit.InvalidDataLogError(
                     'Time must be non-decreasing.')
         if len(self) > 0:
-            n = set([len(v) for v in self.itervalues()])
+            n = set([len(v) for v in self.values()])
             if len(n) > 1:
                 raise myokit.InvalidDataLogError(
                     'All entries in a data log must have the same length.')
@@ -1251,7 +1251,7 @@
                 id_set[k].add(i)
         # Create variable info objects
         infos = {}
-        for name, id_list in id_lists.iteritems():
+        for name, id_list in id_lists.items():
             id_set = id_sets[name]
             # Check if the data is regular.
             n = len(id_list)
@@ -1655,7 +1655,7 @@
                         ' cell-specific variable <' + str(kname) + '>.')
         # Check dict values can be appended to
         m = 'append'
-        for v in log.itervalues():
+        for v in log.values():
             if not (hasattr(v, m) and callable(getattr(v, m))):
                 raise Exception(
                     'Logging dict must map qnames to objects'
@@ -1672,7 +1672,7 @@
         raise Exception(
             'Argument `log` has unexpected type. Expecting None,'
             ' integer flag, sequence of names, dict or DataLog.')
-    if isinstance(log, str) or isinstance(log, unicode):
+    if isinstance(log, str) or isinstance(log, str):
         raise Exception(
             'String passed in as `log` argument, should be list'
             ' or other sequence containing strings.')
@@ -1766,10 +1766,10 @@
     """
     def inner(dims, index, postfix):
         if index == 0:
-            for i in xrange(0, dims[index]):
+            for i in range(0, dims[index]):
                 yield (i,) + postfix
         else:
-            for i in xrange(0, dims[index]):
+            for i in range(0, dims[index]):
                 postfix2 = (i, ) + postfix
                 for y in inner(dims, index - 1, postfix2):
                     yield y
--- ./myokit/_protocol.py	(original)
+++ ./myokit/_protocol.py	(refactored)
@@ -548,7 +548,7 @@
         ]
         x = [str(x) for x in x]
         s = [8, 8, 8, 8, 0]
-        for i in xrange(0, 5):
+        for i in range(0, 5):
             n = s[i] - len(x[i]) + z
             z = 0
             if n > 0:
@@ -591,7 +591,7 @@
         """
         return self._multiplier
 
-    def next(self):
+    def __next__(self):
         """
         If this event is part of a :class:`myokit.Protocol`, this returns the
         next scheduled event.
--- ./myokit/mxml.py	(original)
+++ ./myokit/mxml.py	(refactored)
@@ -9,7 +9,7 @@
 import re
 import xml.dom
 import textwrap
-import HTMLParser
+import html.parser
 
 
 def dom_child(node, selector=None):
@@ -67,13 +67,13 @@
     The ascii will be text-wrapped after ``width`` characters. Each new level
     of nesting will be indented with the text given as ``indent``.
     """
-    class Asciifier(HTMLParser.HTMLParser):
+    class Asciifier(html.parser.HTMLParser):
         INDENT = 1
         DEDENT = -1
         WHITE = [' ', '\t', '\f', '\r', '\n']
 
         def __init__(self, line_width=79, indent='  '):
-            HTMLParser.HTMLParser.__init__(self)  # HTMLParser is old school
+            html.parser.HTMLParser.__init__(self)  # HTMLParser is old school
             self.text = []  # Current document
             self.line = []  # Current (unwrapped) line
             self.limode = None
@@ -352,7 +352,7 @@
         if self._attributes:
             buf.extend([
                 ' ' + k + '="' + v.replace('"', '') + '"' for k, v in
-                self._attributes.iteritems()])
+                self._attributes.items()])
         if self._math:
             buf.extend(('>', self._math, '</', self._name, '>'))
         elif self._pos_kids:
@@ -373,7 +373,7 @@
             raise ValueError(
                 'Node type "' + self._name + '" does not support attribute "'
                 + str(attribute) + '".')
-        self._attributes[attribute] = unicode(value)
+        self._attributes[attribute] = str(value)
 
     def text(self, text):
         """
@@ -386,7 +386,7 @@
                 + '".')
         # Create, append and return
         node = TinyHtmlNode('text', TinyHtmlScheme.text_def)
-        node._text = unicode(text)
+        node._text = str(text)
         self._kids.append(node)
         return node
 
--- ./myokit/pype.py	(original)
+++ ./myokit/pype.py	(refactored)
@@ -12,7 +12,7 @@
 import sys
 import parser
 import traceback
-from cStringIO import StringIO
+from io import StringIO
 
 
 class TemplateEngine(object):
@@ -73,7 +73,7 @@
                 syserr = sys.stderr
                 sys.stdout = stdout
                 sys.stderr = stderr
-                exec(script) in variables
+                exec((script), variables)
             except Exception:
                 error = sys.exc_info()
             finally:
@@ -240,14 +240,14 @@
     args = arg.parse_args()
     filename = os.path.abspath(args.filename)
     if not os.path.exists(filename):
-        print('Error: Template not found: "' + filename + '"')
+        print(('Error: Template not found: "' + filename + '"'))
         exit(1)
     e = TemplateEngine()
     try:
-        print(e.process(filename, variables))
+        print((e.process(filename, variables)))
     except PypeError:
         print('Pype error:')
-        print(e.message)
+        print((e.message))
         d = e.error_details()
         if d:
             print(d)
--- ./myokit/_parser.py	(original)
+++ ./myokit/_parser.py	(refactored)
@@ -26,10 +26,10 @@
     """
     # Get raw stream
     raw = source
-    if type(raw) in [str, unicode]:
+    if type(raw) in [str, str]:
         raw = raw.splitlines()
     try:
-        raw.next
+        raw.__next__
     except AttributeError:
         raw = iter(raw)
     # Create tokenizer
@@ -56,7 +56,7 @@
                     'Expecting [[script]]')
         script = parse_script_from_stream(stream, raw)
     else:
-        expect(stream.next(), EOF)
+        expect(next(stream), EOF)
     # Return
     return (model, protocol, script)
 
@@ -67,10 +67,10 @@
     """
     # Get raw stream
     raw = source
-    if type(raw) in [str, unicode]:
+    if type(raw) in [str, str]:
         raw = raw.splitlines()
     try:
-        raw.next
+        raw.__next__
     except AttributeError:
         raw = iter(raw)
     # Parse and return
@@ -81,7 +81,7 @@
             'Invalid segment header', token[2], token[3],
             'Expecting [[model]]')
     model = parse_model_from_stream(stream)
-    expect(stream.next(), EOF)
+    expect(next(stream), EOF)
     return model
 
 
@@ -91,10 +91,10 @@
     """
     # Get raw stream
     raw = source
-    if type(raw) in [str, unicode]:
+    if type(raw) in [str, str]:
         raw = raw.splitlines()
     try:
-        raw.next
+        raw.__next__
     except AttributeError:
         raw = iter(raw)
     # Parse and return
@@ -105,7 +105,7 @@
             'Invalid segment header', token[2], token[3],
             'Expecting [[protocol]]')
     protocol = parse_protocol_from_stream(stream)
-    expect(stream.next(), EOF)
+    expect(next(stream), EOF)
     return protocol
 
 
@@ -115,10 +115,10 @@
     """
     # Get raw stream
     raw = source
-    if type(raw) in [str, unicode]:
+    if type(raw) in [str, str]:
         raw = raw.splitlines()
     try:
-        raw.next
+        raw.__next__
     except AttributeError:
         raw = iter(raw)
     # Parse and return
@@ -129,7 +129,7 @@
             'Invalid segment header', token[2], token[3],
             'Expecting [[script]]')
     script = parse_script_from_stream(stream)
-    expect(stream.next(), EOF)
+    expect(next(stream), EOF)
     return script
 
 
@@ -157,10 +157,10 @@
     """
     # Get raw stream
     raw = state
-    if type(raw) in [str, unicode]:
+    if type(raw) in [str, str]:
         raw = raw.splitlines()
     try:
-        raw.next
+        raw.__next__
     except AttributeError:
         raw = iter(raw)
     # Create tokenizer
@@ -170,17 +170,17 @@
         # Parse name = value format
         pairs = {}
         while stream.peek()[0] != EOF:
-            name = expect(stream.next(), NAME)[1]
+            name = expect(next(stream), NAME)[1]
             t = stream.peek()
             if t[0] != DOT:
                 raise ParseError(
                     'Unexpected token, expecting "."', t[2], t[3],
                     'All variable names must be fully qualified: comp.var')
-            expect(stream.next(), DOT)
-            name += '.' + expect(stream.next(), NAME)[1]
-            expect(stream.next(), EQUAL)
+            expect(next(stream), DOT)
+            name += '.' + expect(next(stream), NAME)[1]
+            expect(next(stream), EQUAL)
             pairs[name] = parse_expression_stream(stream).eval()
-            t = expect(stream.next(), EOL)
+            t = expect(next(stream), EOL)
         return pairs
     else:
         # Parse list-of-floats format
@@ -188,7 +188,7 @@
         state = []
         while True:
             while stream.peek()[0] not in expr:
-                stream.next()
+                next(stream)
             if stream.peek()[0] == EOF:
                 return state
             state.append(parse_expression_stream(stream).eval())
@@ -201,10 +201,10 @@
     """
     # Get raw stream
     raw = source
-    if type(raw) in [str, unicode]:
+    if type(raw) in [str, str]:
         raw = raw.splitlines()
     try:
-        raw.next
+        raw.__next__
     except AttributeError:
         raw = iter(raw)
     segments = ['', '', '']
@@ -223,7 +223,7 @@
     try:
         stream = Tokenizer(iter(lines))
         while stream.peek()[0] == EOL:
-            stream.next()
+            next(stream)
         token = stream.peek()
         if token[0] == SEGMENT_HEADER and token[1] == '[[model]]':
             parse_model_from_stream(stream, syntax_only=True)
@@ -249,7 +249,7 @@
     # Try parsing protocol
     try:
         while stream.peek()[0] == EOL:
-            stream.next()
+            next(stream)
         token = stream.peek()
         if token[0] == SEGMENT_HEADER and token[1] == '[[protocol]]':
             parse_protocol_from_stream(stream)
@@ -353,12 +353,12 @@
     # Create parse info object
     info = ParseInfo()
     # Parse header definition
-    token = expect(stream.next(), SEGMENT_HEADER)
+    token = expect(next(stream), SEGMENT_HEADER)
     if token[1][2:-2] != 'model':
         raise ParseError(
             'Invalid segment header', token[2], token[3],
             'Expecting [[model]]')
-    expect(stream.next(), EOL)
+    expect(next(stream), EOL)
     # Create model
     model = info.model = myokit.Model()
     reg_token(info, token, model)
@@ -370,38 +370,38 @@
             parse_user_function(stream, info)
         elif token[0] == META_NAME:
             # Meta data
-            t = stream.next()
+            t = next(stream)
             meta_key = t[1].strip()
             if meta_key in model.meta:
                 raise ParseError(
                     'Duplicate meta-data property', t[2], t[3],
                     'The meta-data property "' + meta_key + '" was already'
                     ' specified for this model.')
-            expect(stream.next(), COLON)
-            next = expect(stream.next(), [TEXT, EOL])
+            expect(next(stream), COLON)
+            next = expect(next(stream), [TEXT, EOL])
             meta_val = ''
             if next[0] == TEXT:
                 meta_val = next[1].strip()
-                expect(stream.next(), EOL)
+                expect(next(stream), EOL)
             model.meta[meta_key] = meta_val
         else:
             # Initial value
-            t0 = stream.next()
-            t1 = expect(stream.next(), DOT)
-            t2 = expect(stream.next(), NAME)
+            t0 = next(stream)
+            t1 = expect(next(stream), DOT)
+            t2 = expect(next(stream), NAME)
             name = t0[1] + t1[1] + t2[1]
             if name in info.initial_values:
                 raise ParseError(
                     'Duplicate initial value', t0[2], t0[3],
                     'A value for <' + name + '> was already specified.')
-            expect(stream.next(), EQUAL)
+            expect(next(stream), EQUAL)
             expr = parse_expression_stream(stream)
-            expect(stream.next(), EOL)
+            expect(next(stream), EOL)
             info.initial_values[name] = expr
             reg_token(info, t0, expr)
         token = stream.peek()
     # Save order of state variables
-    state_order = info.initial_values.keys()
+    state_order = list(info.initial_values.keys())
     # Parse components
     while stream.peek()[0] == BRACKET_OPEN:
         parse_component(stream, info)
@@ -410,7 +410,7 @@
     if syntax_only:
         return True
     # All initial variables must have been used
-    for qname, e in info.initial_values.iteritems():
+    for qname, e in info.initial_values.items():
         raise ParseError(
             'Unused initial value', 0, 0,
             'An unused initial value was found for "' + str(qname) + '".')
@@ -419,9 +419,9 @@
     # Order encountered tokens
     m = model._tokens
     model._tokens = {}
-    for line in sorted(m.iterkeys()):
+    for line in sorted(m.keys()):
         model._tokens[line] = {}
-        for char in sorted(m[line].iterkeys()):
+        for char in sorted(m[line].keys()):
             model._tokens[line][char] = m[line][char]
     # Resolve alias map
     resolve_alias_map_names(info)
@@ -451,20 +451,20 @@
     Parses a user function.
     """
     # Parse name
-    token, name, line, char = expect(stream.next(), FUNC_NAME)
+    token, name, line, char = expect(next(stream), FUNC_NAME)
     # Parse argument list
     args = []
-    expect(stream.next(), PAREN_OPEN)
-    token = expect(stream.next(), [PAREN_CLOSE, NAME])
+    expect(next(stream), PAREN_OPEN)
+    token = expect(next(stream), [PAREN_CLOSE, NAME])
     while token[0] == NAME:
         args.append(token[1])
-        token = expect(stream.next(), [COMMA, PAREN_CLOSE])
+        token = expect(next(stream), [COMMA, PAREN_CLOSE])
         if token[0] == COMMA:
-            token = expect(stream.next(), NAME)
+            token = expect(next(stream), NAME)
     # Parse template
-    expect(stream.next(), EQUAL)
+    expect(next(stream), EQUAL)
     expr = convert_proto_expression(parse_proto_expression(stream, info))
-    expect(stream.next(), EOL)
+    expect(next(stream), EOL)
     # Create user function
     try:
         info.model.add_function(name, args, expr)
@@ -485,10 +485,10 @@
             'parse_component requires at least a model to be present in its'
             ' ParseInfo.')
     # Parse component declaration
-    expect(stream.next(), BRACKET_OPEN)
-    token = expect(stream.next(), NAME)
-    expect(stream.next(), BRACKET_CLOSE)
-    expect(stream.next(), EOL)
+    expect(next(stream), BRACKET_OPEN)
+    token = expect(next(stream), NAME)
+    expect(next(stream), BRACKET_CLOSE)
+    expect(next(stream), EOL)
     code, name, line, char = token
     try:
         component = info.model.add_component(name)
@@ -509,19 +509,19 @@
             parse_alias(stream, info, component)
         elif token[0] == META_NAME:
             # Meta data
-            t = stream.next()
+            t = next(stream)
             meta_key = t[1].strip()
             if meta_key in component.meta:
                 raise ParseError(
                     'Duplicate meta-data property', t[2], t[3],
                     'The meta-data property "' + meta_key + '" was already'
                     ' specified for this component.')
-            expect(stream.next(), COLON)
-            next = expect(stream.next(), [TEXT, EOL])
+            expect(next(stream), COLON)
+            next = expect(next(stream), [TEXT, EOL])
             meta_val = ''
             if next[0] == TEXT:
                 meta_val = next[1].strip()
-                expect(stream.next(), EOL)
+                expect(next(stream), EOL)
             component.meta[meta_key] = meta_val
         else:
             # Variable
@@ -547,27 +547,27 @@
     except KeyError:
         amap = info.alias_map[component] = {}
     # Parse
-    token = expect(stream.next(), [USE])
+    token = expect(next(stream), [USE])
     while True:
         # Get referenced variable
-        token_c = expect(stream.next(), NAME)   # component
-        token_v = stream.next()                 # dot
+        token_c = expect(next(stream), NAME)   # component
+        token_v = next(stream)                 # dot
         if token_v[0] != DOT:
             raise ParseError(
                 'Invalid reference', token_v[2], token_v[3],
                 'Aliassed variables must be specified using their fully'
                 ' qualified name (component.variable)')
-        token_v = expect(stream.next(), NAME)   # variable
+        token_v = expect(next(stream), NAME)   # variable
         # Get reference name
         if stream.peek()[0] == AS:
-            expect(stream.next(), AS)
-            code, name, line, char = expect(stream.next(), NAME)
+            expect(next(stream), AS)
+            code, name, line, char = expect(next(stream), NAME)
         else:
             code, name, line, char = token_v
         # Create alias
         amap[name] = (token, token_c, token_v)
         # Expecting end of line or next alias
-        next = expect(stream.next(), [COMMA, EOL])
+        next = expect(next(stream), [COMMA, EOL])
         if next[0] == EOL:
             break
 
@@ -588,7 +588,7 @@
     # List of tokens to register with the final variable
     toreg = []
     # Parse variable declaration
-    token = expect(stream.next(), [NAME, FUNC_NAME])
+    token = expect(next(stream), [NAME, FUNC_NAME])
     toreg.append(token)
     code, name, line, char = token
     # Allow dot() function on lhs
@@ -601,9 +601,9 @@
             raise ParseError(
                 'Illegal variable declaration', line, char,
                 'State variable declarations may not be nested.')
-        toreg.append(expect(stream.next(), PAREN_OPEN))
-        token = expect(stream.next(), NAME)
-        toreg.append(expect(stream.next(), PAREN_CLOSE))
+        toreg.append(expect(next(stream), PAREN_OPEN))
+        token = expect(next(stream), NAME)
+        toreg.append(expect(next(stream), PAREN_CLOSE))
         toreg.append(token)
         code, name, line, char = token
         is_state = True
@@ -646,7 +646,7 @@
     token = expect(stream.peek(), (EQUAL, IN, BIND, LABEL, COLON, EOL))
     if token[0] == EQUAL:
         # Parse variable definition
-        stream.next()
+        next(stream)
         # Save proto-expression for right-hand side
         var._proto_rhs = parse_proto_expression(stream, info)
         # Get rest of line
@@ -656,7 +656,7 @@
         var._proto_rhs = None
     if token[0] == IN:
         # Parse variable unit
-        stream.next()
+        next(stream)
         unit = parse_bracketed_unit(stream)
         token = expect(stream.peek(), (BIND, LABEL, COLON, EOL))
     if token[0] == BIND:
@@ -669,13 +669,13 @@
         token = expect(stream.peek(), (COLON, EOL))
     if token[0] == COLON:
         # Colon found, rest of line is description
-        stream.next()
-        desc = expect(stream.next(), TEXT)[1].strip()
+        next(stream)
+        desc = expect(next(stream), TEXT)[1].strip()
         var.meta['desc'] = desc
-    expect(stream.next(), EOL)
+    expect(next(stream), EOL)
     # Parse indented fields (temp vars, meta or unit)
     if stream.peek()[0] == INDENT:
-        stream.next()
+        next(stream)
         while stream.peek()[0] != DEDENT:
             token = expect(stream.peek(), [NAME, META_NAME, IN, BIND, LABEL])
             code, name, line, char = token
@@ -690,13 +690,13 @@
                         'Duplicate meta-data property', line, char,
                         'The meta-data property "' + meta_key + '" was already'
                         ' specified for this variable.')
-                stream.next()
-                expect(stream.next(), COLON)
-                next = expect(stream.next(), [TEXT, EOL])
+                next(stream)
+                expect(next(stream), COLON)
+                next = expect(next(stream), [TEXT, EOL])
                 meta_val = ''
                 if next[0] == TEXT:
                     meta_val = next[1].strip()
-                    expect(stream.next(), EOL)
+                    expect(next(stream), EOL)
                 var.meta[meta_key] = meta_val
             elif token[0] == IN:
                 if unit:
@@ -704,22 +704,22 @@
                         'Duplicate variable unit', line, char,
                         'Unit already specified for this variable.')
                 # Variable unit
-                stream.next()
+                next(stream)
                 unit = parse_bracketed_unit(stream)
-                expect(stream.next(), EOL)
+                expect(next(stream), EOL)
             elif token[0] == BIND:
                 # Binding to external value
                 parse_binding(stream, info, var)
-                expect(stream.next(), EOL)
+                expect(next(stream), EOL)
             elif token[0] == LABEL:
                 # Labelled as unique value
                 parse_label(stream, info, var)
-                expect(stream.next(), EOL)
+                expect(next(stream), EOL)
             else:
                 raise Exception('Unhandled case.')
             # Next line
             token = stream.peek()[0]
-        expect(stream.next(), DEDENT)
+        expect(next(stream), DEDENT)
     # Set unit
     var.set_unit(unit)
     # Normal operation is to leave the ._proto_rhs untouched until the full
@@ -734,9 +734,9 @@
     """
     Parses the "bind" part of a variable definition.
     """
-    token, name, line, char = expect(stream.next(), BIND)
+    token, name, line, char = expect(next(stream), BIND)
     # Get binding label
-    label = expect(stream.next(), NAME)[1]
+    label = expect(next(stream), NAME)[1]
     # Bind variable
     try:
         var.set_binding(label)
@@ -748,9 +748,9 @@
     """
     Parses the "label" part of a variable definition.
     """
-    token, name, line, char = expect(stream.next(), LABEL)
+    token, name, line, char = expect(next(stream), LABEL)
     # Get label
-    label = expect(stream.next(), NAME)[1]
+    label = expect(next(stream), NAME)[1]
     # Register label
     try:
         var.set_label(label)
@@ -768,8 +768,8 @@
      - No two aliasses are tied to the same variable (within a single
       component)
     """
-    for comp, amap in info.alias_map.iteritems():
-        for name, (t_use, t_comp, t_var) in amap.iteritems():
+    for comp, amap in info.alias_map.items():
+        for name, (t_use, t_comp, t_var) in amap.items():
             var_name = t_comp[1] + '.' + t_var[1]
             (var, sug, msg) = info.model.suggest_variable(var_name)
             if var is None:
@@ -793,7 +793,7 @@
     Parses a unit expression and returns a Unit object.
     """
     # Parse first unit in unit expression
-    token = expect(stream.next(), [NAME, INTEGER])
+    token = expect(next(stream), [NAME, INTEGER])
     if token[0] == NAME:
         try:
             unit = myokit.Unit.parse_simple(token[1])
@@ -802,10 +802,10 @@
                 'Unit not recognized', token[2], token[3], ke.message,
                 cause=ke)
         if stream.peek()[0] == POWER:
-            stream.next()
-            expo = expect(stream.next(), (INTEGER, FLOAT, MINUS))[1]
+            next(stream)
+            expo = expect(next(stream), (INTEGER, FLOAT, MINUS))[1]
             if expo == '-':
-                unit **= -float(expect(stream.next(), (INTEGER, FLOAT))[1])
+                unit **= -float(expect(next(stream), (INTEGER, FLOAT))[1])
             else:
                 unit **= float(expo)
     else:
@@ -818,7 +818,7 @@
     # Parse remaining units (* or /)
     while stream.peek()[0] in [STAR, SLASH]:
         op = stream.next()[0]
-        token = expect(stream.next(), NAME)
+        token = expect(next(stream), NAME)
         try:
             part = myokit.Unit.parse_simple(token[1])
         except KeyError as ke:
@@ -826,10 +826,10 @@
                 'Unit not recognized', token[2], token[3], ke.message,
                 cause=ke)
         if stream.peek()[0] == POWER:
-            stream.next()
-            expo = expect(stream.next(), (INTEGER, FLOAT, MINUS))[1]
+            next(stream)
+            expo = expect(next(stream), (INTEGER, FLOAT, MINUS))[1]
             if expo == '-':
-                part **= -float(expect(stream.next(), (INTEGER, FLOAT))[1])
+                part **= -float(expect(next(stream), (INTEGER, FLOAT))[1])
             else:
                 part **= float(expo)
         if op == STAR:
@@ -838,7 +838,7 @@
             unit /= part
     # Parse multiplier
     if stream.peek()[0] == PAREN_OPEN:
-        stream.next()
+        next(stream)
         token = stream.peek()
         e = parse_expression_stream(stream)
         if not e.is_literal():
@@ -846,7 +846,7 @@
                 'Invalid unit multiplier', token[2], token[3],
                 'Unit multipliers cannot contain variables.')
         unit *= e.eval()
-        expect(stream.next(), PAREN_CLOSE)
+        expect(next(stream), PAREN_CLOSE)
     return unit
 
 
@@ -856,10 +856,10 @@
     """
     s = Tokenizer(string)
     e = parse_unit(s)
-    expect(s.next(), EOL)
-    expect(s.next(), EOF)
+    expect(next(s), EOL)
+    expect(next(s), EOF)
     try:
-        s.next()
+        next(s)
         raise ParseError(
             'Unused tokens', 0, 0,
             'Expecting a string containing only a single unit expression.')
@@ -873,9 +873,9 @@
     UNIT token to the unit, allowing later maniplation.
     """
     unit_text = stream.start_catching()
-    token = expect(stream.next(), BRACKET_OPEN)
+    token = expect(next(stream), BRACKET_OPEN)
     unit = parse_unit(stream)
-    expect(stream.next(), BRACKET_CLOSE)
+    expect(next(stream), BRACKET_CLOSE)
     unit_text = stream.stop_catching(unit_text)
     unit._token = (UNIT, unit_text, token[2], token[3])
     return unit
@@ -896,12 +896,12 @@
         return e.eval()
     # Check segment header
     if stream.peek()[0] == SEGMENT_HEADER:
-        token = stream.next()
+        token = next(stream)
         if token[1][2:-2] != 'protocol':
             raise ParseError(
                 'Invalid segment header', token[2], token[3],
                 'Expecting [[protocol]]')
-        expect(stream.next(), EOL)
+        expect(next(stream), EOL)
     # Create protocol
     protocol = myokit.Protocol()
     # Parse lines
@@ -914,7 +914,7 @@
         # Parse starting time
         # Allow 'next' to mean "after the previous event ends"
         if stream.peek()[1] == 'next':
-            stream.next()
+            next(stream)
             if t_next is None:
                 raise ProtocolParseError(
                     'Invalid next', n[2], n[3],
@@ -965,7 +965,7 @@
         else:
             t_next = None
         # Parse end of line
-        expect(stream.next(), EOL)
+        expect(next(stream), EOL)
         # Schedule event
         try:
             protocol.schedule(v, t, d, p, r)
@@ -980,7 +980,7 @@
     """
     Parses a script segment
     """
-    token = expect(stream.next(), SEGMENT_HEADER)
+    token = expect(next(stream), SEGMENT_HEADER)
     if token[1][2:-2] != 'script':
         raise ParseError(
             'Invalid segment header', token[2], token[3],
@@ -1004,7 +1004,7 @@
     This method will raise a :class:`myokit.ParseError` if the given code
     cannot be parsed to a valid model.
     """
-    if type(model_text) in (str, unicode):
+    if type(model_text) in (str, str):
         lines = model_text.splitlines()
     else:
         lines = model_text
@@ -1031,7 +1031,7 @@
         stripped = []
         cuts.sort()
         cuts = iter(cuts)
-        cut = cuts.next()
+        cut = next(cuts)
         for k, line in enumerate(lines):
             if cut and cut[0] == k:
                 # Gather non-unit parts of line
@@ -1050,7 +1050,7 @@
                     line2 += line[offset:char1]
                     offset = char2
                     try:
-                        cut = cuts.next()
+                        cut = next(cuts)
                     except StopIteration:
                         cut = None
                 line = line2 + line[offset:]
@@ -1134,7 +1134,7 @@
     'bind': BIND,
     'label': LABEL,
 }
-KEYWORDS = KEYWORD_MAP.keys()
+KEYWORDS = list(KEYWORD_MAP.keys())
 
 # Tabsize is used to interpret the column a tab will move you to, this affects
 #  the indenting rules
@@ -1244,7 +1244,7 @@
         self._catchers = {}
         self._catcheri = 0
         # String given instead of stream of lines? Convert
-        if type(stream_of_lines) in (str, unicode):
+        if type(stream_of_lines) in (str, str):
             stream_of_lines = iter(stream_of_lines.splitlines())
         # Create tokenizer
         self._tokenizer = self._tizer(stream_of_lines, check_indenting)
@@ -1259,14 +1259,14 @@
         Advances to the next token.
         """
         self._next = self._peek
-        for c in self._catchers.itervalues():
+        for c in self._catchers.values():
             c.append(self._next[1])
         try:
-            self._peek = self._tokenizer.next()
+            self._peek = next(self._tokenizer)
             while self._peek[0] == WHITESPACE:
-                for c in self._catchers.itervalues():
+                for c in self._catchers.values():
                     c.append(self._peek[1])
-                self._peek = self._tokenizer.next()
+                self._peek = next(self._tokenizer)
         except StopIteration:
             self._has_last_value = True
 
@@ -1276,7 +1276,7 @@
         """
         return self._next
 
-    def next(self):
+    def __next__(self):
         """
         Takes the next token from the stream and returns it.
         """
@@ -1753,10 +1753,10 @@
     """
     s = Tokenizer(string)
     e = parse_proto_expression(s)
-    expect(s.next(), EOL)
-    expect(s.next(), EOF)
+    expect(next(s), EOL)
+    expect(next(s), EOF)
     try:
-        s.next()
+        next(s)
         raise ParseError(
             'Unused tokens', 0, 0,
             'Expecting a string containing only a single expression.')
@@ -1771,10 +1771,10 @@
     s = Tokenizer(string)
     p = NumberParser()
     e = p.parse(s, ParseInfo())
-    expect(s.next(), EOL)
-    expect(s.next(), EOF)
+    expect(next(s), EOL)
+    expect(next(s), EOF)
     try:
-        s.next()
+        next(s)
         raise ParseError(
             'Unused tokens', 0, 0, 'Expecting a string containing only a'
             ' single number.')
@@ -1852,11 +1852,11 @@
     line = None
     if ex.line > 0 and source is not None:
         kind = type(source)
-        if (kind == str or kind == unicode) and os.path.isfile(source):
+        if (kind == str or kind == str) and os.path.isfile(source):
             # Re-open file, find line
             f = open(source, 'r')
-            for i in xrange(0, ex.line):
-                line = f.next()
+            for i in range(0, ex.line):
+                line = next(f)
             line = line.rstrip()
         else:
             i = 0
@@ -1919,7 +1919,7 @@
     Parser for numeric literals.
     """
     def parse(self, stream, info):
-        token = stream.next()
+        token = next(stream)
         unit = None
         if stream.peek()[0] == BRACKET_OPEN:
             unit = parse_bracketed_unit(stream)
@@ -1931,12 +1931,12 @@
     Parser for names.
     """
     def parse(self, stream, info):
-        t1 = stream.next()
+        t1 = next(stream)
         t2 = t3 = t4 = None
         name = t1[1]
         if stream.peek()[0] == DOT:
-            t2 = stream.next()
-            t3 = expect(stream.next(), NAME)
+            t2 = next(stream)
+            t3 = expect(next(stream), NAME)
             name += '.' + t3[1]
         return (myokit.Name, (name, ), (t1, t2, t3, t4))
 
@@ -1946,7 +1946,7 @@
     Parser for prefix (single operand) operators.
     """
     def parse(self, stream, info):
-        token = stream.next()
+        token = next(stream)
         arg = parse_proto_expression(stream, info, self._rbp)
         return (self.element, (arg, ), (token,))
 
@@ -1956,9 +1956,9 @@
     Parser for grouping IE parentheses; as in 5 * (2 + 3).
     """
     def parse(self, stream, info):
-        stream.next()
+        next(stream)
         expr = parse_proto_expression(stream, info, self._rbp)
-        expect(stream.next(), PAREN_CLOSE)
+        expect(next(stream), PAREN_CLOSE)
         return expr
 
 
@@ -1971,12 +1971,12 @@
         self._rbp = myokit.Function._rbp
 
     def parse(self, stream, info):
-        name = stream.next()
+        name = next(stream)
         ops = []
-        token = stream.next()
+        token = next(stream)
         while token[0] != PAREN_CLOSE:
             ops.append(parse_proto_expression(stream, info))
-            token = expect(stream.next(), [COMMA, PAREN_CLOSE])
+            token = expect(next(stream), [COMMA, PAREN_CLOSE])
         if name[1] in functions:
             # Predefined function
             func = functions[name[1]]
@@ -2032,7 +2032,7 @@
     Parser for infix operators.
     """
     def parse(self, left, stream, info):
-        token = stream.next()
+        token = next(stream)
         right = parse_proto_expression(stream, info, self._rbp)
         return (self.element, (left, right), (token,))
 
--- ./myokit/_sim/cable.py	(original)
+++ ./myokit/_sim/cable.py	(refactored)
@@ -127,9 +127,9 @@
         fname = os.path.join(myokit.DIR_CFUNC, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(
+            print((
                 self._code(fname, args,
-                           line_numbers=myokit.DEBUG_LINE_NUMBERS))
+                           line_numbers=myokit.DEBUG_LINE_NUMBERS)))
             import sys
             sys.exit(1)
         # Create simulation
--- ./myokit/_core.py	(original)
+++ ./myokit/_core.py	(refactored)
@@ -13,7 +13,7 @@
 
 try:
     # Python 2
-    from cStringIO import StringIO
+    from io import StringIO
 except ImportError:
     # Python 3
     from io import StringIO
@@ -83,7 +83,7 @@
         """
         Clones this object's metadata into ``clone``.
         """
-        for k, v in self.meta.iteritems():
+        for k, v in self.meta.items():
             clone.meta[str(k)] = str(v)
 
     def _code_meta(self, b, tabs=0, ignore=None):
@@ -94,7 +94,7 @@
         """
         if not ignore:
             ignore = []
-        for k, v in sorted(self.meta.iteritems()):
+        for k, v in sorted(self.meta.items()):
             if k in ignore:
                 continue
             v = str(v)
@@ -482,7 +482,7 @@
             return self.add_variable(name)
         except myokit.DuplicateName:
             n_tries = 256
-            for i in xrange(n_tries):
+            for i in range(n_tries):
                 try:
                     return self.add_variable(name + '_' + str(1 + i))
                 except DuplicateName:
@@ -527,14 +527,14 @@
         if deep:
             if sort:
                 def viter(owner):
-                    for n, v in sorted(owner._variables.iteritems()):
+                    for n, v in sorted(owner._variables.items()):
                         yield v
                         for w in v._create_variable_stream(True, True):
                             yield w
                 return viter(self)
             else:
                 def viter(owner):
-                    for v in owner._variables.itervalues():
+                    for v in owner._variables.values():
                         yield v
                         for w in v._create_variable_stream(True, False):
                             yield w
@@ -542,11 +542,11 @@
         else:
             if sort:
                 def viter(owner):
-                    for n, v in sorted(owner._variables.iteritems()):
+                    for n, v in sorted(owner._variables.items()):
                         yield v
                 return viter(self)
             else:
-                return self._variables.itervalues()
+                return iter(self._variables.values())
 
     def get(self, name, class_filter=None):
         """
@@ -780,7 +780,7 @@
             return self.add_component(name)
         except myokit.DuplicateName:
             n_tries = 256
-            for i in xrange(n_tries):
+            for i in range(n_tries):
                 try:
                     return self.add_component(name + '_' + str(1 + i))
                 except DuplicateName:
@@ -850,7 +850,7 @@
         this model.
         """
         # New dict allows removing labels using this iterator
-        return dict(self._bindings).iteritems()
+        return iter(dict(self._bindings).items())
 
     def check_units(self, mode=myokit.UNIT_TOLERANT):
         """
@@ -937,7 +937,7 @@
         # Copy meta data
         self._clone_metadata(clone)
         # Clone component/variable structure
-        for c in self._components.itervalues():
+        for c in self._components.values():
             c._clone1(clone)
         # Clone state
         for k, v in enumerate(self._state):
@@ -950,7 +950,7 @@
             lhsmap[myokit.Derivative(myokit.Name(v))] = myokit.Derivative(
                 myokit.Name(clone.get(v.qname())))
         # Clone component/variable contents (equations, references)
-        for k, c in self._components.iteritems():
+        for k, c in self._components.items():
             c._clone2(clone[k], lhsmap)
         # Copy unique names
         clone.reserve_unique_names(*iter(self._reserved_unames))
@@ -990,7 +990,7 @@
             n = max([len(name) for name in names])
             names = iter(names)
             for eq in self.inits():
-                name = names.next()
+                name = next(names)
                 b.write(
                     pre + name + ' ' * (n - len(name)) + ' = ' + eq.rhs.code()
                     + '\n')
@@ -1007,9 +1007,9 @@
             def i(s):
                 for k, v in s:
                     yield v
-            return i(sorted(self._components.iteritems()))
+            return i(sorted(self._components.items()))
         else:
-            return self._components.itervalues()
+            return iter(self._components.values())
 
     def component_cycles(self):
         """
@@ -1083,7 +1083,7 @@
                 scores[cid] = [1, cycle]
             if len(cycle) < len(scores[cid][1]):
                 scores[cid][1] = cycle
-        cycles = scores.values()
+        cycles = list(scores.values())
         cycles.sort(key=lambda x: -x[0])
         return [x[1] for x in cycles]
 
@@ -1199,7 +1199,7 @@
             # Check if values in ``inputs`` are all numbers
             temp = inputs
             inputs = {}
-            for label, number in temp.iteritems():
+            for label, number in temp.items():
                 if label in self._bindings:
                     inputs[label] = float(number)
             del(temp)
@@ -1215,7 +1215,7 @@
 
         # Evaluate all variables in solvable order
         values = {}
-        for group in order.itervalues():
+        for group in order.values():
             for eq in group:
                 values[eq.lhs] = eq.rhs.eval(
                     values, precision=precision, ignore_errors=ignore_errors)
@@ -1231,7 +1231,7 @@
 
         # Reset original values of variables set to external inputs
         if inputs is not None:
-            for var, rhs in org_inputs.iteritems():
+            for var, rhs in org_inputs.items():
                 var.set_rhs(rhs)
 
         # Return calculated state
@@ -1335,7 +1335,7 @@
             add_dep(lhs)
 
         # Filter out dependencies on arguments
-        for dps in shallow.itervalues():
+        for dps in shallow.values():
             for arg in arguments:
                 if arg in dps:
                     dps.remove(arg)
@@ -1344,7 +1344,7 @@
         eq_list = []
         while len(shallow):
             done = []
-            for lhs, dps in shallow.iteritems():
+            for lhs, dps in shallow.items():
                 if len(dps) == 0:
                     eq_list.append(Equation(lhs, equations[lhs]))
                     done.append(lhs)
@@ -1352,7 +1352,7 @@
                 raise Exception('Failed to solve system of equations.')
             for lhs in done:
                 del(shallow[lhs])
-                for dps in shallow.itervalues():
+                for dps in shallow.values():
                     if lhs in dps:
                         dps.remove(lhs)
 
@@ -1532,7 +1532,7 @@
         Returns an iterator over all (label : variable) mappings in this model.
         """
         # New dict allows removing labels using this iterator
-        return dict(self._labels).iteritems()
+        return iter(dict(self._labels).items())
 
     def __len__(self):
         return len(self._components)
@@ -1579,14 +1579,14 @@
         for comp in self.components():
             deps[comp] = set()
         # Gather dependencies per component
-        for lhs, dps in shallow.iteritems():
+        for lhs, dps in shallow.items():
             c1 = lhs.var().parent(Component)
             for dep in dps:
                 c2 = dep.var().parent(Component)
                 if c2 != c1:
                     deps[c1].add(c2)
         # Convert sets to lists
-        for comp, dps in deps.iteritems():
+        for comp, dps in deps.items():
             deps[comp] = list(dps)
         # Return
         return deps
@@ -1650,7 +1650,7 @@
                 do[var.parent(Component)].add(var.lhs())
 
         # Add inputs and outputs
-        for user, deps in shallow.iteritems():
+        for user, deps in shallow.items():
             c_user = user.var().parent(Component)
             for usee in deps:
                 c_usee = usee.var().parent(Component)
@@ -1727,7 +1727,7 @@
 
         # Store set of lhs's found by following equations
         equations = dict(
-            zip(shallow.keys(), [x.rhs() for x in shallow.keys()]))
+            list(zip(list(shallow.keys()), [x.rhs() for x in list(shallow.keys())])))
 
         # Add state variables
         if not omit_states:
@@ -1776,7 +1776,7 @@
         # Collapse nesting
         if collapse:
             nested = []
-            for x, y in deep.iteritems():
+            for x, y in deep.items():
                 var = x.var()
                 if var.is_nested():
                     nested.append(x)
@@ -1786,7 +1786,7 @@
                     for rhs in y:
                         var.add(rhs)
             for x in nested:
-                for y in deep.itervalues():
+                for y in deep.values():
                     if x in y:
                         y.remove(x)
             for x in nested:
@@ -1794,7 +1794,7 @@
 
         # Filter encompassed variables
         if filter_encompassed:
-            for x, xdeps in deep.iteritems():
+            for x, xdeps in deep.items():
                 tofilter = []
                 for y in xdeps:
                     if y.is_state_value():
@@ -1865,7 +1865,7 @@
         # Collapse nested variables
         if collapse:
             nested = []
-            for x, y in out.iteritems():
+            for x, y in out.items():
                 var = x.var()
                 if var.is_nested():
                     nested.append(x)
@@ -1875,7 +1875,7 @@
                     for rhs in y:
                         var.add(rhs)
             for x in nested:
-                for y in out.itervalues():
+                for y in out.values():
                     if x in y:
                         y.remove(x)
             for x in nested:
@@ -1909,7 +1909,7 @@
 
         """
         n = self.count_states()
-        if type(state) in [str, unicode]:
+        if type(state) in [str, str]:
             # String given. Parse into name:float map or list
             state = myokit.parse_state(state)
         if isinstance(state, dict):
@@ -2003,7 +2003,7 @@
         """
         unused = []
         variables = {}
-        for label, var in self._bindings.iteritems():
+        for label, var in self._bindings.items():
             try:
                 variables[var] = labels[label]
             except KeyError:
@@ -2285,14 +2285,14 @@
         cdeps = self.map_component_dependencies()
         while True:
             new = []
-            for comp, deps in cdeps.iteritems():
+            for comp, deps in cdeps.items():
                 if comp not in solvable_comps and len(deps) == 0:
                     solvable_comps.append(comp)
                     new.append(comp)
             if len(new) == 0:
                 break
             for comp in new:
-                for deps in cdeps.itervalues():
+                for deps in cdeps.values():
                     if comp in deps:
                         deps.remove(comp)
 
@@ -2324,7 +2324,7 @@
 
         def expand(par):
             expd = []
-            for var, eq in nested.iteritems():
+            for var, eq in nested.items():
                 if var._parent == par:
                     expand(var)
                     eq_list.append(eq)
@@ -2346,11 +2346,11 @@
                 done.append(lhs)
 
         # Now handle each component, as far as we get
-        for comp, eqs in todo.iteritems():
+        for comp, eqs in todo.items():
             eq_list = out[comp.name()]
             while True:
                 done = []
-                for lhs, eq in eqs.iteritems():
+                for lhs, eq in eqs.items():
                     if len(deps[lhs]) == 0:
                         addeq(lhs, eq, done)
                 if len(done) == 0:
@@ -2359,15 +2359,15 @@
                     # Remove from todo list, remove all deps on done lhs's
                     del eqs[lhs]
                     del deps[lhs]
-                    for dps in deps.itervalues():
+                    for dps in deps.values():
                         if lhs in dps:
                             dps.remove(lhs)
 
         # Get remaining equations
         todd = todo
         todo = {}
-        for comp, eqs in todd.iteritems():
-            for lhs, eq in eqs.iteritems():
+        for comp, eqs in todd.items():
+            for lhs, eq in eqs.items():
                 todo[lhs] = eq
         del(todd)   # Bye todd!
 
@@ -2375,7 +2375,7 @@
         out['*remaining*'] = eq_list = EquationList()
         while True:
             done = []
-            for lhs, eq in todo.iteritems():
+            for lhs, eq in todo.items():
                 if len(deps[lhs]) == 0:
                     addeq(lhs, eq, done)
             if len(done) == 0:
@@ -2383,7 +2383,7 @@
             for lhs in done:
                 del todo[lhs]
                 del deps[lhs]
-                for dps in deps.itervalues():
+                for dps in deps.values():
                     if lhs in dps:
                         dps.remove(lhs)
         if len(todo):
@@ -2411,7 +2411,7 @@
               ' LhsExpression objects or string names of variables'
         roots = set()
         for lhs in args:
-            if type(lhs) in (str, unicode):
+            if type(lhs) in (str, str):
                 lhs = self.get(lhs)
                 if not isinstance(lhs, myokit.Variable):
                     raise ValueError(msg)
@@ -2458,7 +2458,7 @@
         eqs = EquationList()
         while deps:
             todo = set()
-            for lhs, dps in deps.iteritems():
+            for lhs, dps in deps.items():
                 if not dps:
                     todo.add(lhs)
             if not todo:
@@ -2466,7 +2466,7 @@
             for lhs in todo:
                 del(deps[lhs])
                 eqs.append(Equation(lhs, lhs.rhs()))
-            for lhs, dps in deps.iteritems():
+            for lhs, dps in deps.items():
                 deps[lhs] -= todo
         return eqs
 
@@ -2614,7 +2614,7 @@
             # Deep validation
             c.validate(fix_crudely)
         # Test component mapping
-        for n, c in self._components.iteritems():
+        for n, c in self._components.items():
             if n != c.qname():
                 self._valid = False
                 raise myokit.IntegrityError(
@@ -2679,8 +2679,8 @@
         # Follow all state variables (unless already visited), all bound
         # variables and all used variables.
         used = [x for x in self._state]
-        used += [x for x in self._bindings.itervalues()]
-        used += [x for x in self._labels.itervalues()]
+        used += [x for x in self._bindings.values()]
+        used += [x for x in self._labels.values()]
 
         # Check for cycles
         trail = []
@@ -2844,7 +2844,7 @@
         """
         model = component.model()
         # Clone alias map
-        for k, v in self._alias_map.iteritems():
+        for k, v in self._alias_map.items():
             component.add_alias(k, model.get(v.qname()))
         # Clone equations
         for v in self.variables():
@@ -2906,7 +2906,7 @@
         Returns an alias for the :class:`Variable` variable. Raises a
         ``KeyError`` if no such alias is found.
         """
-        for alias, var in self._alias_map.iteritems():
+        for alias, var in self._alias_map.items():
             if var == variable:
                 return alias
         raise KeyError('No alias found for <' + variable.qname() + '>.')
@@ -2920,7 +2920,7 @@
         # Append meta properties
         self._code_meta(b, t)
         # Append aliases
-        for alias, var in self._alias_map.iteritems():
+        for alias, var in self._alias_map.items():
             b.write(pre + 'use ' + var.qname() + ' as ' + alias + '\n')
         # Append values
         for v in self.variables(sort=True):
@@ -2945,7 +2945,7 @@
         Returns ``True`` if this :class:`Component` has an alias for the given
         :class:`Variable`.
         """
-        return variable in self._alias_map.itervalues()
+        return variable in iter(self._alias_map.values())
 
     def remove_alias(self, name):
         """
@@ -2958,7 +2958,7 @@
         Removes any alias for the given variable from this :class:`Component`.
         """
         todo = []
-        for name, avar in self._alias_map.iteritems():
+        for name, avar in self._alias_map.items():
             if avar == var:
                 todo.append(name)
         for name in todo:
@@ -3407,7 +3407,7 @@
         eqs, args = self.model().expressions_for(self)
         # Handle function arguments
         func = [w.ex(x) for x in args]
-        func, args = zip(*sorted(zip(func, args)))  # Sort both following func
+        func, args = list(zip(*sorted(zip(func, args))))  # Sort both following func
         # Create function text
         func = ['def var_pyfunc_generated(' + ','.join(func) + '):']
         tab = '\t'
@@ -3607,7 +3607,7 @@
         """
         # Handle string and number rhs's
         if not isinstance(rhs, myokit.Expression):
-            if type(rhs) in (str, unicode):
+            if type(rhs) in (str, str):
                 rhs = myokit.parse_expression(rhs, context=self)
             else:
                 rhs = myokit.Number(rhs)
@@ -3658,7 +3658,7 @@
         """
         if unit is None or isinstance(unit, myokit.Unit):
             self._unit = unit
-        elif type(unit) in (str, unicode):
+        elif type(unit) in (str, str):
             self._unit = myokit.Unit.parse_simple(unit)
         else:
             raise TypeError('Method set_unit() expects a myokit.Unit or None.')
--- ./myokit/_sim/cvode.py	(original)
+++ ./myokit/_sim/cvode.py	(refactored)
@@ -109,9 +109,9 @@
         fname = os.path.join(myokit.DIR_CFUNC, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(
+            print((
                 self._code(
-                    fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS))
+                    fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS)))
             import sys
             sys.exit(1)
         # Create simulation
@@ -399,7 +399,7 @@
             dr = []
             if root_list:
                 roots = iter(root_list)
-                time, direction = roots.next()
+                time, direction = next(roots)
                 tlast = time if direction > 0 else None
                 for time, direction in roots:
                     if direction > 0:
--- ./myokit/_expr.py	(original)
+++ ./myokit/_expr.py	(refactored)
@@ -15,7 +15,7 @@
 
 try:
     # Python 2
-    from cStringIO import StringIO
+    from io import StringIO
 except ImportError:
     # Python3
     from io import StringIO
@@ -323,7 +323,7 @@
     def __ne__(self, other):
         return not self.__eq__(other)
 
-    def __nonzero__(self):
+    def __bool__(self):
         return True
 
     def operator_rep(self):
@@ -538,7 +538,7 @@
             self._value = float(value) if value else 0.0
             if unit is None or isinstance(unit, myokit.Unit):
                 self._unit = unit
-            elif type(unit) in [str, unicode]:
+            elif type(unit) in [str, str]:
                 self._unit = myokit.parse_unit(unit)
             else:
                 raise ValueError(
@@ -678,7 +678,7 @@
     def __init__(self, value):
         super(Name, self).__init__()
         if not isinstance(value, myokit.Variable):
-            if type(value) not in [str, unicode]:
+            if type(value) not in [str, str]:
                 raise ValueError(
                     'myokit.Name objects must have a value that is a'
                     ' myokit.Variable (or, when debugging, a string).')
@@ -1303,7 +1303,7 @@
         b.write('(')
         if len(self._operands) > 0:
             self._operands[0]._code(b, c)
-            for i in xrange(1, len(self._operands)):
+            for i in range(1, len(self._operands)):
                 b.write(', ')
                 self._operands[i]._code(b, c)
         b.write(')')
@@ -1815,10 +1815,10 @@
         self._i = [0] * m           # Conditions
         self._e = [0] * (m + 1)     # Expressions
         oper = iter(ops)
-        for i in xrange(0, m):
-            self._i[i] = oper.next()
-            self._e[i] = oper.next()
-        self._e[m] = oper.next()
+        for i in range(0, m):
+            self._i[i] = next(oper)
+            self._e[i] = next(oper)
+        self._e[m] = next(oper)
 
     def conditions(self):
         """
@@ -1839,7 +1839,7 @@
         # Check if the options have the same unit (or None)
         d = myokit.units.dimensionless
         units = iter(units)
-        shared = units.next()
+        shared = next(units)
         for u in units:
             if u == shared:         # Normal case + propagating Nones
                 continue
@@ -1912,13 +1912,13 @@
         self._p = [0] * (m - 1)     # Points
         self._e = [0] * m           # Expressions (pieces)
         oper = iter(ops)
-        oper.next()
+        next(oper)
         last = None
-        for i in xrange(0, m - 1):
-            self._e[i] = oper.next()
-            op = oper.next()
+        for i in range(0, m - 1):
+            self._e[i] = next(oper)
+            op = next(oper)
             if not op.is_literal():
-                print op
+                print(op)
                 raise myokit.NonLiteralValueError(
                     'The points splitting the domain of an OrderedPiecewise'
                     ' function must be given as literal values.')
@@ -1933,7 +1933,7 @@
                         ' strictly increasing (' + str(next) + ' <= '
                         + str(last) + ').')
                 last = next
-        self._e[m - 1] = oper.next()
+        self._e[m - 1] = next(oper)
 
     def count_pieces(self):
         """
@@ -1943,7 +1943,7 @@
 
     def _eval(self, subst, precision):
         x = self._x._eval(subst, precision)
-        for i in xrange(len(self._p), 0, -1):
+        for i in range(len(self._p), 0, -1):
             if x >= self._p[i - 1]._eval(subst, precision):
                 return self._e[i]._eval(subst, precision)
         return self._e[0]._eval(subst, precision)
@@ -1971,7 +1971,7 @@
                 ' same unit as the variable.')
         # Check if all possible values have the same unit
         units = iter(e_units)
-        shared = units.next()
+        shared = next(units)
         for u in units:
             if u == shared:         # Normal case + propagating Nones
                 continue
@@ -2103,13 +2103,13 @@
         n = len(self._c)
         if horner:
             p = self._c[-1]
-            for i in xrange(n - 2, -1, -1):
+            for i in range(n - 2, -1, -1):
                 p = Plus(self._c[i], Multiply(self._x, p))
         else:
             p = self._c[0]
             if n > 1:
                 p = Plus(p, Multiply(self._c[1], self._x))
-                for i in xrange(2, n):
+                for i in range(2, n):
                     p = Plus(
                         p, Multiply(self._c[i], Power(self._x, Number(i))))
         return p
@@ -2623,7 +2623,7 @@
     }
 
     # Mapping of SI quantifier symbols to their values
-    _si_quantifiers = dict((v, k) for k, v in _si_exponents.iteritems())
+    _si_quantifiers = dict((v, k) for k, v in _si_exponents.items())
 
     def __init__(self, exponents=None, multiplier=0):
         if exponents is None:
@@ -2739,7 +2739,7 @@
         defining a new Unit.
         """
         e = []
-        for i in xrange(0, 7):
+        for i in range(0, 7):
             u = Unit()
             u._x[i] = 1
             e.append(u)
--- ./myokit/_sim/icsim.py	(original)
+++ ./myokit/_sim/icsim.py	(refactored)
@@ -7,7 +7,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import division
+
 import os
 import myokit
 import numpy as np
@@ -93,7 +93,7 @@
         # Create initial list of derivatives
         n = len(self._state)
         self._deriv = [0.0] * n**2
-        for i in xrange(n):
+        for i in range(n):
             self._deriv[i * (n + 1)] = 1.0
         # Starting time
         self._time = 0
@@ -111,8 +111,8 @@
         fname = os.path.join(myokit.DIR_CFUNC, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(self._code(
-                fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS))
+            print((self._code(
+                fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS)))
             import sys
             sys.exit(1)
         # Create simulation
@@ -145,7 +145,7 @@
                 + str(shape) + '.')
         # Create datablock
         block = myokit.DataBlock2d(n, n, time)
-        for k, v in log.iteritems():
+        for k, v in log.items():
             if k != tvar:
                 block.set0d(k, v)
         block.set2d('derivatives', derivatives)
@@ -180,7 +180,7 @@
         # Reset derivatives
         n = len(self._state)
         self._deriv = [0.0] * n**2
-        for i in xrange(n):
+        for i in range(n):
             self._deriv[i * (n + 1)] = 1.0
 
     def run(self, duration, log=None, log_interval=5, progress=None,
--- ./myokit/_sim/jacobian.py	(original)
+++ ./myokit/_sim/jacobian.py	(refactored)
@@ -63,9 +63,9 @@
         fname = os.path.join(myokit.DIR_CFUNC, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(
+            print((
                 self._code(fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS)
-            )
+            ))
             import sys
             sys.exit(1)
         # Compile extension
@@ -142,7 +142,7 @@
                 'The given log must contain an entry for <' + time + '>.')
         nstates = self._model.count_states()
         block = myokit.DataBlock2d(nstates, nstates, time)
-        for k, v in log.iteritems():
+        for k, v in log.items():
             if k != tvar:
                 block.set0d(k, v)
         # Create iterators over lists of state and input values
@@ -153,9 +153,9 @@
         ns2 = ns * ns
         # Pass every state into the generator, store the output
         partials = []
-        for i in xrange(n):
-            state = [x.next() for x in istates]
-            bound = [x.next() for x in iinputs]
+        for i in range(n):
+            state = [next(x) for x in istates]
+            bound = [next(x) for x in iinputs]
             deriv = [0] * ns
             partial = [0] * ns2
             self._ext.calculate(state, bound, deriv, partial)
@@ -230,9 +230,9 @@
         fname = os.path.join(myokit.DIR_CFUNC, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(
+            print((
                 self._code(fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS)
-            )
+            ))
             import sys
             sys.exit(1)
         # Compile extension
--- ./myokit/_sim/opencl.py	(original)
+++ ./myokit/_sim/opencl.py	(refactored)
@@ -8,7 +8,7 @@
 #
 import os
 import myokit
-import ConfigParser
+import configparser
 
 
 # Settings file
@@ -92,7 +92,7 @@
         # Read ini file
         inifile = os.path.expanduser(SETTINGS_FILE)
         if os.path.isfile(inifile):
-            config = ConfigParser.ConfigParser()
+            config = configparser.ConfigParser()
             config.read(inifile)
 
             def get(section, option):
@@ -117,7 +117,7 @@
         Both platform and device are identified by their names.
         """
         # Create configuration
-        config = ConfigParser.ConfigParser()
+        config = configparser.ConfigParser()
         config.add_section('selection')
         if platform:
             config.set('selection', 'platform', platform)
--- ./myokit/_sim/psim.py	(original)
+++ ./myokit/_sim/psim.py	(refactored)
@@ -167,9 +167,9 @@
 
         # Debug
         if myokit.DEBUG:
-            print(
+            print((
                 self._code(fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS)
-            )
+            ))
             import sys
             sys.exit(1)
 
@@ -204,7 +204,7 @@
                 + str(shape) + '.')
         # Create datablock
         block = myokit.DataBlock2d(m, n, time)
-        for k, v in log.iteritems():
+        for k, v in log.items():
             if k != tvar:
                 block.set0d(k, v)
         block.set2d('derivatives', derivatives)
--- ./myokit/_sim/rhs.py	(original)
+++ ./myokit/_sim/rhs.py	(refactored)
@@ -53,9 +53,9 @@
         fname = os.path.join(myokit.DIR_CFUNC, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(
+            print((
                 self._code(fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS)
-            )
+            ))
             import sys
             sys.exit(1)
         # Create extension
@@ -146,7 +146,7 @@
         import numpy as np
         times = np.array(times, copy=False)
         # Remove outliers twice
-        for i in xrange(0, 2):
+        for i in range(0, 2):
             avg = np.mean(times)
             std = np.std(times)
             s3 = std * 3
@@ -183,7 +183,7 @@
         else:
             self._variables = set()
             for var in variables:
-                if type(var) in (str, unicode):
+                if type(var) in (str, str):
                     # String? Then get variable from model
                     var = self._model.get(var)
                 else:
--- ./myokit/formats/ansic/__init__.py	(original)
+++ ./myokit/formats/ansic/__init__.py	(refactored)
@@ -6,8 +6,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _exporter import AnsiCExporter, AnsiCCableExporter, AnsiCEulerExporter
-from _ewriter import AnsiCExpressionWriter
+from ._exporter import AnsiCExporter, AnsiCCableExporter, AnsiCEulerExporter
+from ._ewriter import AnsiCExpressionWriter
 
 
 # Importers
--- ./myokit/formats/ansic/_ewriter.py	(original)
+++ ./myokit/formats/ansic/_ewriter.py	(refactored)
@@ -99,12 +99,12 @@
         s = []
         n = len(e._i)
         if self.cFunc is None:
-            for i in xrange(0, n):
+            for i in range(0, n):
                 s.append('(%s ? %s : ' % (self.ex(e._i[i]), self.ex(e._e[i])))
             s.append(self.ex(e._e[n]))
             s.append(')' * n)
         else:
-            for i in xrange(0, n):
+            for i in range(0, n):
                 s.append(
                     '%s(%s, %s, ' % (
                         self.cFunc, self.ex(e._i[i]), self.ex(e._e[i])))
--- ./myokit/_sim/fiber_tissue.py	(original)
+++ ./myokit/_sim/fiber_tissue.py	(refactored)
@@ -10,7 +10,7 @@
 import myokit
 
 # OpenCLSim keywords
-from openclsim import KEYWORDS
+from .openclsim import KEYWORDS
 
 # Location of C and OpenCL sources
 SOURCE_FILE = 'fiber_tissue.c'
@@ -184,8 +184,8 @@
                 'The width of the stimulus pulse must be non-negative.')
         nx_paced = min(nx_paced, self._ncellsf[0])
         self._paced_cells = []
-        for y in xrange(self._ncellsf[1]):
-            for x in xrange(min(self._ncellsf[0], nx_paced)):
+        for y in range(self._ncellsf[1]):
+            for x in range(min(self._ncellsf[0], nx_paced)):
                 self._paced_cells.append(x + y * self._ncellsf[0])
 
         # Check conductivities
@@ -345,9 +345,9 @@
         fname = os.path.join(myokit.DIR_CFUNC, SOURCE_FILE)
         # Create simulation module
         if myokit.DEBUG:
-            print(
+            print((
                 self._code(fname, args, line_numbers=myokit.DEBUG_LINE_NUMBERS)
-            )
+            ))
             return
         libs = ['OpenCL']
         libd = list(myokit.OPENCL_LIB)
@@ -447,7 +447,7 @@
         def find_error_position(log):
             ifirst = None   # Log list index
             kfirst = None   # Log key
-            for key, ar in log.iteritems():
+            for key, ar in log.items():
                 if ifirst is None:
                     if not np.isfinite(ar[-1]):
                         # First NaN found
@@ -564,7 +564,7 @@
         states = []
         bound = []
         max_states = 3
-        for k in xrange(ifirst, ifirst - max_states - 1, -1):
+        for k in range(ifirst, ifirst - max_states - 1, -1):
             if k < 0:
                 break
             s, b = state(k, icell)
@@ -728,7 +728,7 @@
         # Create list of intermediary fiber variables that need to be logged
         inter_logf = []
         vars_checked = set()
-        for var in logf.iterkeys():
+        for var in logf.keys():
             var = myokit.split_key(var)[1]
             if var in vars_checked:
                 continue
@@ -740,7 +740,7 @@
         # Create list of intermediary tissue variables that need to be logged
         inter_logt = []
         vars_checked = set()
-        for var in logt.iterkeys():
+        for var in logt.keys():
             var = myokit.split_key(var)[1]
             if var in vars_checked:
                 continue
@@ -766,11 +766,11 @@
         args['inter_log'] = inter_logf
         args['paced_cells'] = self._paced_cells
         if myokit.DEBUG:
-            print('-' * 79)
-            print(
+            print(('-' * 79))
+            print((
                 self._code(kernel_file, args,
                            line_numbers=myokit.DEBUG_LINE_NUMBERS)
-            )
+            ))
         else:
             kernelf = self._export(kernel_file, args)
         args['model'] = self._modelt
@@ -779,11 +779,11 @@
         args['inter_log'] = inter_logt
         args['paced_cells'] = []
         if myokit.DEBUG:
-            print('-' * 79)
-            print(
+            print(('-' * 79))
+            print((
                 self._code(kernel_file, args,
                            line_numbers=myokit.DEBUG_LINE_NUMBERS)
-            )
+            ))
             import sys
             sys.exit(1)
         else:
--- ./myokit/formats/axon/__init__.py	(original)
+++ ./myokit/formats/axon/__init__.py	(refactored)
@@ -6,9 +6,9 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _abf import AbfFile, Sweep, Channel
-from _atf import AtfFile, load_atf, save_atf
-from _importer import AbfImporter
+from ._abf import AbfFile, Sweep, Channel
+from ._atf import AtfFile, load_atf, save_atf
+from ._importer import AbfImporter
 
 # Importers
 _importers = {
--- ./myokit/formats/axon/_atf.py	(original)
+++ ./myokit/formats/axon/_atf.py	(refactored)
@@ -48,7 +48,7 @@
         """
         Returns a list containing this ATF file's data as (key, value) pairs.
         """
-        return self._data.items()
+        return list(self._data.items())
 
     def __iter__(self):
         """
@@ -60,19 +60,19 @@
         """
         Iterates over all key-value pairs in this ATF file's data.
         """
-        return self._data.iteritems()
+        return iter(self._data.items())
 
     def iterkeys(self):
         """
         Iterates over all keys in this ATF file's data.
         """
-        return self._data.iterkeys()
+        return iter(self._data.keys())
 
     def itervalues(self):
         """
         Iterates over all values in this ATF file's data.
         """
-        return self._data.itervalues()
+        return iter(self._data.values())
 
     def __len__(self):
         """
@@ -90,7 +90,7 @@
         """
         Returns a list containing this ATF file's keys.
         """
-        return self._data.keys()
+        return list(self._data.keys())
 
     def myokit_log(self):
         """
@@ -99,8 +99,8 @@
         import myokit
         log = myokit.DataLog()
         if len(self._data) > 0:
-            log.set_time_key(self._data.iterkeys().next())
-        for k, v in self._data.iteritems():
+            log.set_time_key(next(iter(self._data.keys())))
+        for k, v in self._data.items():
             log[k] = v
         return log
 
@@ -126,7 +126,7 @@
             val = []    # Values
             raw = []    # Fallback
             key_value_pairs = True
-            for i in xrange(nh):
+            for i in range(nh):
                 line = f.readline().strip()
                 line_index += 1
                 if line[0] != '"' or line[-1] != '"':
@@ -148,7 +148,7 @@
                 meta = []
                 val = iter(val)
                 for k in key:
-                    v = val.next()
+                    v = next(val)
                     meta.append(k + ' ' * (n - len(k)) + ' = ' + v)
                 self._meta = '\n'.join(meta)
             else:
@@ -178,7 +178,7 @@
                 a, b = 0, 0
                 if line[a] != '"':
                     raise Exception('Unable to parse columns headers.')
-                for i in xrange(nf):
+                for i in range(nf):
                     b = line.index('"', a + 1)
                     keys.append(line[a + 1:b])
                     a = line.index('"', b + 1)
@@ -263,7 +263,7 @@
             except KeyError:
                 raise ValueError('Variable <' + field + '> not found in log.')
     else:
-        for k, v in log.iteritems():
+        for k, v in log.items():
             if k != time:
                 keys.append(k)
                 data.append(iter(v))
@@ -300,6 +300,6 @@
         # Write field names
         f.write(delim.join(['"' + k + '"' for k in keys]) + eol)
         # Write data
-        for i in xrange(nd):
+        for i in range(nd):
             f.write(
-                delim.join([myokit.strfloat(d.next()) for d in data]) + eol)
+                delim.join([myokit.strfloat(next(d)) for d in data]) + eol)
--- ./myokit/_sim/openclsim.py	(original)
+++ ./myokit/_sim/openclsim.py	(refactored)
@@ -231,9 +231,9 @@
             'dims': len(self._dims),
         }
         if myokit.DEBUG:
-            print(
+            print((
                 self._code(fname, args,
-                           line_numbers=myokit.DEBUG_LINE_NUMBERS))
+                           line_numbers=myokit.DEBUG_LINE_NUMBERS)))
             return
         libs = ['OpenCL']
         libd = list(myokit.OPENCL_LIB)
@@ -369,7 +369,7 @@
                 # Search for first occurrence of propagating NaN in the log
                 ifirst = None
                 kfirst = None
-                for key, ar in log.iteritems():
+                for key, ar in log.items():
                     if ifirst is None:
                         if not np.isfinite(ar[-1]):
                             # First NaN found
@@ -513,7 +513,7 @@
         states = []
         bound = []
         max_states = 3
-        for k in xrange(ifirst, ifirst - max_states - 1, -1):
+        for k in range(ifirst, ifirst - max_states - 1, -1):
             if k < 0:
                 break
             s, b = state(k, icell)
@@ -704,7 +704,7 @@
         # Create list of intermediary variables that need to be logged
         inter_log = []
         vars_checked = set()
-        for var in log.iterkeys():
+        for var in log.keys():
             var = myokit.split_key(var)[1]
             if var in vars_checked:
                 continue
@@ -725,14 +725,14 @@
             'bound_variables': self._bound_variables,
             'inter_log': inter_log,
             'diffusion': self._diffusion_enabled,
-            'fields': self._fields.keys(),
+            'fields': list(self._fields.keys()),
             'paced_cells': self._paced_cells,
         }
         if myokit.DEBUG:
-            print('-' * 79)
-            print(
+            print(('-' * 79))
+            print((
                 self._code(kernel_file, args,
-                           line_numbers=myokit.DEBUG_LINE_NUMBERS))
+                           line_numbers=myokit.DEBUG_LINE_NUMBERS)))
             import sys
             sys.exit(1)
         kernel = self._export(kernel_file, args)
@@ -745,7 +745,7 @@
         # Create field values vector
         n = len(self._fields) * self._nx * self._ny
         if n:
-            field_data = self._fields.itervalues()
+            field_data = iter(self._fields.values())
             field_data = [np.array(x, copy=False) for x in field_data]
             field_data = np.vstack(field_data)
             field_data = list(field_data.reshape(n, order='F'))
--- ./myokit/formats/cellml/__init__.py	(original)
+++ ./myokit/formats/cellml/__init__.py	(refactored)
@@ -6,9 +6,9 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _importer import CellMLImporter, CellMLError
-from _exporter import CellMLExporter
-from _ewriter import CellMLExpressionWriter
+from ._importer import CellMLImporter, CellMLError
+from ._exporter import CellMLExporter
+from ._ewriter import CellMLExpressionWriter
 
 
 # Importers
--- ./myokit/formats/__init__.py	(original)
+++ ./myokit/formats/__init__.py	(refactored)
@@ -390,7 +390,7 @@
             raise Myokit.ExportError(msg, self)
         # Render all templates
         tpl_vars = self._vars(model, protocol, *args)
-        for tpl_name, out_name in self._dict().iteritems():
+        for tpl_name, out_name in self._dict().items():
             # Create any dirs embedded in output file path
             file_dir = os.path.split(out_name)[0]
             if file_dir:
@@ -510,7 +510,7 @@
             x = m.importers()
         except AttributeError:
             x = {}
-        for k, v in x.iteritems():
+        for k, v in x.items():
             if k in _IMPORTERS:
                 raise Exception('Duplicate importer name: "'+str(k)+'".')
             _IMPORTERS[k] = v
@@ -518,7 +518,7 @@
             x = m.exporters()
         except AttributeError:
             x = {}
-        for k, v in x.iteritems():
+        for k, v in x.items():
             if k in _EXPORTERS:
                 raise Exception('Duplicate exporter name: "'+str(k)+'".')
             _EXPORTERS[k] = v
@@ -526,7 +526,7 @@
             x = m.ewriters()
         except AttributeError:
             x = {}
-        for k, v in x.iteritems():
+        for k, v in x.items():
             if k in _EWRITERS:
                 raise Exception('Duplicate expression writer name: "'
                     + str(k) + '".')
--- ./myokit/formats/channelml/__init__.py	(original)
+++ ./myokit/formats/channelml/__init__.py	(refactored)
@@ -6,7 +6,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _importer import ChannelMLImporter, ChannelMLError
+from ._importer import ChannelMLImporter, ChannelMLError
 
 
 # Importers
--- ./myokit/formats/cellml/_exporter.py	(original)
+++ ./myokit/formats/cellml/_exporter.py	(refactored)
@@ -216,7 +216,7 @@
                 add_unit(e.unit())
 
         # Add si units to unit map
-        for unit, name in si_units.iteritems():
+        for unit, name in si_units.items():
             unit_map[unit] = name
 
         # Add components
@@ -263,7 +263,7 @@
 
         # Add variables
         evars = {}
-        for parent, eparent in ecomps.iteritems():
+        for parent, eparent in ecomps.items():
             for var in parent.variables():
                 evar = et.SubElement(eparent, 'variable')
                 evars[var] = evar
@@ -284,7 +284,7 @@
         # Add variable interfaces, connections
         deps = model.map_shallow_dependencies(
             omit_states=False, omit_constants=False)
-        for var, evar in evars.iteritems():
+        for var, evar in evars.items():
             # Scan all variables, iterate over the vars they depend on
             par = var.parent()
             lhs = var.lhs()
--- ./myokit/formats/cpp/__init__.py	(original)
+++ ./myokit/formats/cpp/__init__.py	(refactored)
@@ -7,7 +7,7 @@
 #  See: http://myokit.org
 #
 import myokit.formats.ansic
-from _ewriter import CppExpressionWriter
+from ._ewriter import CppExpressionWriter
 
 
 # Importers
--- ./myokit/formats/cuda/__init__.py	(original)
+++ ./myokit/formats/cuda/__init__.py	(refactored)
@@ -6,8 +6,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _exporter import CudaKernelExporter
-from _ewriter import CudaExpressionWriter
+from ._exporter import CudaKernelExporter
+from ._ewriter import CudaExpressionWriter
 from myokit.formats import ansic
 
 
--- ./myokit/formats/channelml/_importer.py	(original)
+++ ./myokit/formats/channelml/_importer.py	(refactored)
@@ -9,7 +9,7 @@
 import os
 import textwrap
 from xml.dom import minidom
-from cStringIO import StringIO
+from io import StringIO
 import myokit
 from myokit import formats
 from myokit import Name, Number, Minus, Multiply, Divide, Power
@@ -284,7 +284,7 @@
             '&ge;': '>=',
         }
         s = s.replace('&amp;', '&')
-        for k, v in entities.iteritems():
+        for k, v in entities.items():
             s = s.replace(k, v)
         # Attempt to handle single a?b:c construct
         if '?' in s:
--- ./myokit/formats/latex/__init__.py	(original)
+++ ./myokit/formats/latex/__init__.py	(refactored)
@@ -7,8 +7,8 @@
 #  See: http://myokit.org
 #
 # Exporters
-from _exporter import PdfExporter, PosterExporter
-from _ewriter import LatexExpressionWriter
+from ._exporter import PdfExporter, PosterExporter
+from ._ewriter import LatexExpressionWriter
 
 _exporters = {
     'latex-article' : PdfExporter,
--- ./myokit/formats/cellml/_importer.py	(original)
+++ ./myokit/formats/cellml/_importer.py	(refactored)
@@ -354,8 +354,8 @@
                         + '>.')
 
         # Check for references that are never connected
-        for cname, rfs in references.iteritems():
-            for vname, ref in rfs.iteritems():
+        for cname, rfs in references.items():
+            for vname, ref in rfs.items():
                 if ref is None:
                     self.warn(
                         'Unresolved reference <' + str(vname) + '> in'
@@ -368,8 +368,8 @@
 
         # The references should now all point to either a variable or a
         # reference to another variable. In the next step, these are resolved.
-        for cname, rfs in references.iteritems():
-            for vname, ref in rfs.iteritems():
+        for cname, rfs in references.items():
+            for vname, ref in rfs.items():
                 if type(ref) == tuple:
                     while True:
                         ref = references[ref[0]][ref[1]]
@@ -450,7 +450,7 @@
                             ' algebraic equations are not supported).')
                     # Check variable
                     var = lhs.var()
-                    if var not in vrs.values():
+                    if var not in list(vrs.values()):
                         raise CellMLError(
                             'Error: Equation found for unknown variable <'
                             + str(var) + '>.')
@@ -477,9 +477,9 @@
             self.log('Found ' + str(n) + ' equations in ' + cname + '.')
 
         # Use remaining initial values (can be used to set constants)
-        for cname, vls in values.iteritems():
+        for cname, vls in values.items():
             vrs = variables[cname]
-            for vname, val in vls.iteritems():
+            for vname, val in vls.items():
                 vrs[vname].set_rhs(myokit.Number(val))
 
         # Bind time variable to engine time
@@ -639,7 +639,7 @@
             todo = units
             units = odict()
             # List units that can already be referenced at this point
-            okay = si_units.keys()
+            okay = list(si_units.keys())
             if global_units:
                 for name, unit in global_units:
                     okay.append(name)
@@ -667,7 +667,7 @@
                     units[unit.name] = unit
             return units
         munits = order(munits)
-        for name, units in cunits.iteritems():
+        for name, units in cunits.items():
             cunits[name] = order(units)
 
         # Convert units
@@ -720,12 +720,12 @@
             return base
 
         # Convert all units in <model>
-        for name, obj in munits.iteritems():
+        for name, obj in munits.items():
             munits[name] = convert(obj)
 
         # Convert all units in components
-        for cname, units in cunits.iteritems():
-            for name, obj in units.iteritems():
+        for cname, units in cunits.items():
+            for name, obj in units.items():
                 units[name] = convert(obj, units)
 
         # Return unit maps
--- ./myokit/formats/cuda/_ewriter.py	(original)
+++ ./myokit/formats/cuda/_ewriter.py	(refactored)
@@ -134,7 +134,7 @@
     def _ex_piecewise(self, e):
         s = []
         n = len(e._i)
-        for i in xrange(0, n):
+        for i in range(0, n):
             s.append('(')
             s.append(self.ex(e._i[i]))
             s.append(' ? ')
--- ./myokit/formats/mathml/__init__.py	(original)
+++ ./myokit/formats/mathml/__init__.py	(refactored)
@@ -6,9 +6,9 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _parser import parse_mathml, parse_mathml_rhs, MathMLError
-from _exporter import XMLExporter, HTMLExporter
-from _ewriter import MathMLExpressionWriter
+from ._parser import parse_mathml, parse_mathml_rhs, MathMLError
+from ._exporter import XMLExporter, HTMLExporter
+from ._ewriter import MathMLExpressionWriter
 
 
 # Importers
--- ./myokit/formats/latex/_exporter.py	(original)
+++ ./myokit/formats/latex/_exporter.py	(refactored)
@@ -8,7 +8,7 @@
 #
 import os
 import myokit
-from _ewriter import LatexExpressionWriter
+from ._ewriter import LatexExpressionWriter
 
 
 class PdfExporter(myokit.formats.Exporter):
--- ./myokit/formats/mathml/_exporter.py	(original)
+++ ./myokit/formats/mathml/_exporter.py	(refactored)
@@ -9,7 +9,7 @@
 import os
 import myokit
 import xml.etree.cElementTree as et
-from _ewriter import MathMLExpressionWriter
+from ._ewriter import MathMLExpressionWriter
 
 
 class XMLExporter(myokit.formats.Exporter):
--- ./myokit/formats/matlab/__init__.py	(original)
+++ ./myokit/formats/matlab/__init__.py	(refactored)
@@ -6,8 +6,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _exporter import MatlabExporter
-from _ewriter import MatlabExpressionWriter
+from ._exporter import MatlabExporter
+from ._ewriter import MatlabExpressionWriter
 
 
 # Importers
--- ./myokit/formats/matlab/_ewriter.py	(original)
+++ ./myokit/formats/matlab/_ewriter.py	(refactored)
@@ -95,7 +95,7 @@
     def _ex_piecewise(self, e):
         s = []
         n = len(e._i)
-        for i in xrange(0, n):
+        for i in range(0, n):
             s.append(self.cFunc)
             s.append('(')
             s.append(self.ex(e._i[i]))
--- ./myokit/formats/axon/_abf.py	(original)
+++ ./myokit/formats/axon/_abf.py	(refactored)
@@ -141,7 +141,7 @@
 # Information - but no direct code - from the matlab script get_abf_header.m
 # was also used: http://neurodata.hg.sourceforge.net/hgweb/neurodata/neurodata/
 #------------------------------------------------------------------------------
-from __future__ import division
+
 from collections import OrderedDict
 import numpy as np
 import traceback
@@ -243,7 +243,7 @@
             self._protocol = self._read_protocol()
         except Exception:
             print('Warning: Unable to read protocol')
-            print(traceback.format_exc())
+            print((traceback.format_exc()))
             self._protocol = []
 
         # The measured data as a list of sweeps
@@ -272,7 +272,7 @@
             return data
         data.append(np.array(self._sweeps[0][channel].times()))
         for sweep in self._sweeps:
-            data.append(np.array(sweep[channel].values()))
+            data.append(np.array(list(sweep[channel].values())))
         return data
 
     def extract_channel_as_myokit_log(self, channel=0):
@@ -290,7 +290,7 @@
         log.set_time_key('time')
         log['time'] = np.array(self._sweeps[0][channel].times())
         for k, sweep in enumerate(self._sweeps):
-            log['sweep', k] = np.array(sweep[channel].values())
+            log['sweep', k] = np.array(list(sweep[channel].values()))
         return log
 
     def filename(self):
@@ -361,7 +361,7 @@
         def show_dict(name, d, tab=''):
             m = max(0, 38 - len(tab) - int(0.1 + len(name) / 2))
             out.append(tab + '-' * m + '  ' + name + '  ' + '-' * m)
-            for n, v in d.iteritems():
+            for n, v in d.items():
                 n = str(n)
                 if type(v) == OrderedDict:
                     show_dict(n, v, tab + '  ')
@@ -403,7 +403,7 @@
             for channel in sweep:
                 if times is None:
                     times = channel.times()
-                pl.plot(times, channel.values())
+                pl.plot(times, list(channel.values()))
         for sweep in self.protocol():
             n = len(sweep)
             times = None
@@ -412,7 +412,7 @@
                     times = channel.times()
                 pl.subplot(2, n, n + 1 + i)
                 pl.title(channel.name())
-                pl.plot(times, channel.values())
+                pl.plot(times, list(channel.values()))
         return f
 
     def myokit_log(self):
@@ -433,19 +433,19 @@
             time = []
             ad_channels = []
             da_channels = []
-            for i in xrange(self.data_channels()):
+            for i in range(self.data_channels()):
                 ad_channels.append([])
-            for i in xrange(self.protocol_channels()):
+            for i in range(self.protocol_channels()):
                 da_channels.append([])
             for sweep in self:
                 for channel in sweep:
                     time.append(channel.times())
                     break
                 for i, channel in enumerate(sweep):
-                    ad_channels[i].append(channel.values())
+                    ad_channels[i].append(list(channel.values()))
             for sweep in self.protocol():
                 for i, channel in enumerate(sweep):
-                    da_channels[i].append(channel.values())
+                    da_channels[i].append(list(channel.values()))
             # Combine into time series, store in log
             log['time'] = np.concatenate(time)
             log.set_time_key('time')
@@ -860,7 +860,7 @@
                 return index in h['epochInfoPerDAC']
 
             def einfo(index):
-                for e in h['epochInfoPerDAC'][index].itervalues():
+                for e in h['epochInfoPerDAC'][index].values():
                     yield {
                         'type': e['nEpochType'],
                         'init_duration': e['lEpochInitDuration'],
@@ -923,16 +923,16 @@
                             # samples in the recording
                             i2 = nSam
                         level = e['init_level'] + e['level_inc'] * iSweep
-                        c._data[i1:i2] = level * np.ones(len(range(i2 - i1)))
+                        c._data[i1:i2] = level * np.ones(len(list(range(i2 - i1))))
                         i_last += dur
                         if i_last > nSam:
                             # The protocol may extend beyond the number of
                             # samples in the recording
                             break
                     else:
-                        print(
+                        print((
                             'Warning: Unsupported epoch type: '
-                            + epoch_types(kind))
+                            + epoch_types(kind)))
                         continue
             sweeps.append(sweep)
             start += self._sweepStartToStart
--- ./myokit/formats/opencl/_ewriter.py	(original)
+++ ./myokit/formats/opencl/_ewriter.py	(refactored)
@@ -128,7 +128,7 @@
     def _ex_piecewise(self, e):
         s = []
         n = len(e._i)
-        for i in xrange(0, n):
+        for i in range(0, n):
             s.append('(')
             s.append(self.ex(e._i[i]))
             s.append(' ? ')
--- ./myokit/formats/mathml/_parser.py	(original)
+++ ./myokit/formats/mathml/_parser.py	(refactored)
@@ -221,7 +221,7 @@
                 else:
                     raise MathMLError('Operator needs at least two operands')
             ex = kind(ops[0], ops[1])
-            for i in xrange(2, n):
+            for i in range(2, n):
                 ex = kind(ex, ops[i])
             return ex
         # Start parsing
@@ -515,7 +515,7 @@
             f = iter(funcs)
             for c in conds:
                 args.append(c)
-                args.append(f.next())
+                args.append(next(f))
             args.append(other)
             return myokit.Piecewise(*args)
         #
--- ./myokit/formats/opencl/template/minilog.py	(original)
+++ ./myokit/formats/opencl/template/minilog.py	(refactored)
@@ -92,7 +92,7 @@
             # Get enumerated iterator over characters
             line = enumerate(line)
             try:
-                i, c = line.next()
+                i, c = next(line)
             except StopIteration:
                 e(1, i, 'Empty line, expecting header.')
             run1 = True
@@ -103,14 +103,14 @@
                     run2 = True
                     while run2:
                         try:
-                            i, c = line.next()
+                            i, c = next(line)
                         except StopIteration:
                             e(
                                 1, i,
                                 'Unexpected end-of-line inside quoted string.')
                         if c == quote:
                             try:
-                                i, c = line.next()
+                                i, c = next(line)
                                 if c == quote:
                                     text.append(quote)
                                 elif c == delim:
@@ -129,14 +129,14 @@
                     while run1 and c != delim:
                         try:
                             text.append(c)
-                            i, c = line.next()
+                            i, c = next(line)
                         except StopIteration:
                             run1 = False
                 # Append new field to list
                 keys.append(''.join(text))
                 # Read next character
                 try:
-                    i, c = line.next()
+                    i, c = next(line)
                 except StopIteration:
                     run1 = False
             if c == delim:
@@ -178,7 +178,7 @@
         """
         import numpy as np
         out = DataLog()
-        for k, d in self.iteritems():
+        for k, d in self.items():
             out[k] = np.array(d, copy=False)
         return out
 
@@ -211,7 +211,7 @@
             keys = []
             data = []
             n = []
-            for key, dat in sorted(self.iteritems()):
+            for key, dat in sorted(self.items()):
                 keys.append(key)
                 data.append(iter(dat))
                 n.append(len(dat))
@@ -236,17 +236,17 @@
             f.write(eol)
             # Write data
             if pad is None:
-                for i in xrange(0, n):
+                for i in range(0, n):
                     line = []
                     for d in data:
-                        line.append(myokit.strfloat(d.next()))
+                        line.append(myokit.strfloat(next(d)))
                     f.write(delim.join(line) + eol)
             else:
-                for i in xrange(0, n):
+                for i in range(0, n):
                     line = []
                     for d in data:
                         try:
-                            line.append(myokit.strfloat(d.next()))
+                            line.append(myokit.strfloat(next(d)))
                         except StopIteration:
                             line.append('0')
                     f.write(delim.join(line) + eol)
--- ./myokit/formats/python/__init__.py	(original)
+++ ./myokit/formats/python/__init__.py	(refactored)
@@ -6,8 +6,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _exporter import PythonExporter
-from _ewriter import PythonExpressionWriter, NumpyExpressionWriter
+from ._exporter import PythonExporter
+from ._ewriter import PythonExpressionWriter, NumpyExpressionWriter
 
 # Importers
 # Exporters
--- ./myokit/formats/opencl/template/plot.py	(original)
+++ ./myokit/formats/opencl/template/plot.py	(refactored)
@@ -31,7 +31,7 @@
     x = (np.tile(np.arange(ncell), (ntime, 1))).transpose()
     y = np.tile(time, (ncell, 1))
     z = np.zeros((ncell, ntime))
-    for k in xrange(ncell):
+    for k in range(ncell):
         z[k][:] = log.get(vname, k)
     import matplotlib.pyplot as pl
     f = pl.figure()
--- ./myokit/formats/sbml/__init__.py	(original)
+++ ./myokit/formats/sbml/__init__.py	(refactored)
@@ -6,7 +6,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _importer import SBMLImporter, SBMLError
+from ._importer import SBMLImporter, SBMLError
 
 
 # Importers
--- ./myokit/formats/opencl/__init__.py	(original)
+++ ./myokit/formats/opencl/__init__.py	(refactored)
@@ -6,8 +6,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _exporter import OpenCLExporter
-from _ewriter import OpenCLExpressionWriter
+from ._exporter import OpenCLExporter
+from ._ewriter import OpenCLExpressionWriter
 from myokit.formats import ansic
 
 
--- ./myokit/formats/stan/__init__.py	(original)
+++ ./myokit/formats/stan/__init__.py	(refactored)
@@ -6,8 +6,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _exporter import StanExporter
-from _ewriter import StanExpressionWriter
+from ._exporter import StanExporter
+from ._ewriter import StanExpressionWriter
 
 
 # Importers
--- ./myokit/formats/stan/_ewriter.py	(original)
+++ ./myokit/formats/stan/_ewriter.py	(refactored)
@@ -93,7 +93,7 @@
     def _ex_piecewise(self, e):
         s = []
         n = len(e._i)
-        for i in xrange(0, n):
+        for i in range(0, n):
             s.append('(%s ? %s: ' % (self.ex(e._i[i]), self.ex(e._e[i])))
         s.append(self.ex(e._e[n]))
         s.append(')' * n)
--- ./myokit/formats/stan/_exporter.py	(original)
+++ ./myokit/formats/stan/_exporter.py	(refactored)
@@ -77,7 +77,7 @@
 
         # Check model output variable
         if output is None:
-            output = model.states().next()
+            output = next(model.states())
         else:
             output = model.get(str(output))
 
--- ./myokit/formats/sympy/__init__.py	(original)
+++ ./myokit/formats/sympy/__init__.py	(refactored)
@@ -6,8 +6,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _ereader import SymPyExpressionReader
-from _ewriter import SymPyExpressionWriter
+from ._ereader import SymPyExpressionReader
+from ._ewriter import SymPyExpressionWriter
 
 
 # Importers
--- ./myokit/formats/wcp/__init__.py	(original)
+++ ./myokit/formats/wcp/__init__.py	(refactored)
@@ -6,7 +6,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from _wcp import WcpFile
+from ._wcp import WcpFile
 # Importers
 # Exporters
 # Expression writers
--- ./myokit/formats/python/_ewriter.py	(original)
+++ ./myokit/formats/python/_ewriter.py	(refactored)
@@ -166,7 +166,7 @@
     def _ex_piecewise(self, e):
         s = ''
         n = len(e) // 2
-        for i in xrange(0, n):
+        for i in range(0, n):
             s += '(' + self.ex(e._e[i]) + ' if ' + self.ex(e._i[i]) + ' else '
         s += self.ex(e._e[n])
         s += ')' * n
@@ -239,11 +239,11 @@
     def _ex_piecewise(self, e):
         n = len(e._i)
         s = [self.function_prefix, 'select([']
-        for i in xrange(0, n):
+        for i in range(0, n):
             s.append(self.ex(e._i[i]))
             s.append(', ')
         s.append('], [')
-        for i in xrange(0, n):
+        for i in range(0, n):
             s.append(self.ex(e._e[i]))
             s.append(', ')
         s.append('], ')
--- ./myokit/formats/wcp/_wcp.py	(original)
+++ ./myokit/formats/wcp/_wcp.py	(refactored)
@@ -78,7 +78,7 @@
         # Tidy up read data
         header = {}
         header_raw = {}
-        for k, v in h.iteritems():
+        for k, v in h.items():
             # Convert to appropriate data type
             try:
                 t = HEADER_FIELDS[k]
@@ -110,10 +110,10 @@
         # Get channel specific fields
         channel_headers = []
         self._channel_names = []
-        for i in xrange(self._nc):
+        for i in range(self._nc):
             j = str(i)
             c = {}
-            for k, t in HEADER_CHANNEL_FIELDS.iteritems():
+            for k, t in HEADER_CHANNEL_FIELDS.items():
                 c[k] = t(h[k + j])
             channel_headers.append(c)
             self._channel_names.append(c['yn'])
@@ -135,7 +135,7 @@
         # Read data records
         records = []
         offset = header_size
-        for i in xrange(self._nr):
+        for i in range(self._nr):
             # Read analysis block
             f.seek(offset)
             # Status of signal (Accepted or rejected, as string)
@@ -165,7 +165,7 @@
             )
             # Separate channels and apply scaling
             record = []
-            for j in xrange(self._nc):
+            for j in range(self._nc):
                 h = channel_headers[j]
                 s = float(vmax[j]) / float(adcmax) / float(h['yg'])
                 d = np.array(data[:, h['yo']].astype('f4') * s)
--- ./myokit/gui/__init__.py	(original)
+++ ./myokit/gui/__init__.py	(refactored)
@@ -199,7 +199,7 @@
     'edit-find' : 'find.png',
     'media-playback-start' : 'run.png',
     }
-for k, v in ICONS.iteritems():
+for k, v in ICONS.items():
     ICONS[k] = os.path.join(ICON_PATH, v)
 # Toolbar style suitable for platform
 TOOL_BUTTON_STYLE = Qt.ToolButtonTextUnderIcon
--- ./myokit/formats/sympy/_ewriter.py	(original)
+++ ./myokit/formats/sympy/_ewriter.py	(refactored)
@@ -174,7 +174,7 @@
     def _ex_piecewise(self, e):
         pairs = []
         n = len(e) // 2
-        for i in xrange(0, n):
+        for i in range(0, n):
             pairs.append((self.ex(e._e[i]), self.ex(e._i[i])))
         pairs.append((self.ex(e._e[n]), True))
         return sp.Piecewise(*pairs)
--- ./myokit/gui/explorer.py	(original)
+++ ./myokit/gui/explorer.py	(refactored)
@@ -7,8 +7,8 @@
 #  See: http://myokit.org
 #
 # Future stuff
-from __future__ import division
-from __future__ import print_function
+
+
 # Standard library imports
 # Myokit
 import myokit
@@ -16,7 +16,7 @@
 from myokit.gui import QtCore, QtGui, QtWidgets
 # GUI components
 import myokit.gui
-import progress
+from . import progress
 # Matplotlib (must be imported _after_ gui has had chance to set backend)
 import matplotlib
 import matplotlib.figure
@@ -193,7 +193,7 @@
         reset_keys = True
         if self._keys:
             # Only reset keys if the old set differs from the new
-            if self._keys == set(d.iterkeys()):
+            if self._keys == set(d.keys()):
                 reset_keys = False
         # Append or reset old data
         reset_plot = True
@@ -210,10 +210,10 @@
             y = self._select_y.currentText()
             self._select_x.clear()
             self._select_y.clear()
-            for k in sorted(d.iterkeys()):
+            for k in sorted(d.keys()):
                 self._select_x.addItem(k)
                 self._select_y.addItem(k)
-            self._keys = set(d.iterkeys())
+            self._keys = set(d.keys())
             # Attempt to keep current variables
             x = self._select_x.findText(x)
             if x < 0:
@@ -223,7 +223,7 @@
             y = self._select_y.findText(y)
             if y < 0:
                 # Guess: First log entry (first state)
-                y = self._select_y.findText(d.iterkeys().next())
+                y = self._select_y.findText(next(iter(d.keys())))
             self._select_y.setCurrentIndex(y)
         # Add new data
         self._data.append(d)
--- ./myokit/gui/datalog_viewer.py	(original)
+++ ./myokit/gui/datalog_viewer.py	(refactored)
@@ -7,13 +7,13 @@
 #  See: http://myokit.org
 #
 # Future stuff
-from __future__ import division
-from __future__ import print_function
+
+
 # Standard library imports
 import gc
 import os
 import traceback
-import ConfigParser as configparser
+import configparser as configparser
 # Qt imports
 from myokit.gui import QtWidgets, QtGui, QtCore, Qt
 # Myokit
@@ -386,10 +386,10 @@
         self._abf = abf
         self._figures = []
         self._axes = []
-        for i in xrange(self._abf.data_channels()):
+        for i in range(self._abf.data_channels()):
             tab, name = self.create_graph_tab(i)
             self.addTab(tab, name)
-        for i in xrange(self._abf.protocol_channels()):
+        for i in range(self._abf.protocol_channels()):
             tab, name = self.create_protocol_tab(i)
             self.addTab(tab, name)
         self.addTab(self.create_info_tab(), 'Info')
@@ -415,7 +415,7 @@
                 name = 'AD' + str(sweep[channel].number()) + ': ' \
                     + sweep[channel].name()
                 times = sweep[channel].times()
-            axes.plot(times, sweep[channel].values())
+            axes.plot(times, list(sweep[channel].values()))
         # Create a layout
         vbox = QtWidgets.QVBoxLayout()
         vbox.addWidget(canvas)
@@ -445,7 +445,7 @@
                 name = 'DA' + str(sweep[channel].number()) + ': ' \
                     + sweep[channel].name()
                 times = sweep[channel].times()
-            axes.plot(times, sweep[channel].values())
+            axes.plot(times, list(sweep[channel].values()))
         # Create a layout
         vbox = QtWidgets.QVBoxLayout()
         vbox.addWidget(canvas)
@@ -512,7 +512,7 @@
             return
 
         # Add tab for each column
-        for k, v in log.iteritems():
+        for k, v in log.items():
             if k == time:
                 continue
             self.addTab(self.create_graph_tab(k, v), k)
@@ -567,7 +567,7 @@
         self._axes = []
 
         # Find usable data
-        for key in mat.keys():
+        for key in list(mat.keys()):
             if key[:1] == '_':
                 continue
             time, data = None, None
@@ -735,7 +735,7 @@
         self._wcp = wcp
         self._figures = []
         self._axes = []
-        for i in xrange(self._wcp.records()):
+        for i in range(self._wcp.records()):
             self.addTab(self.create_graph_tab(i), 'Record ' + str(i))
         del(self._wcp)
 
@@ -752,7 +752,7 @@
         axes = figure.add_subplot(1, 1, 1)
         toolbar = backend.NavigationToolbar2QT(canvas, widget)
         # Draw lines
-        for i in xrange(self._wcp.channels()):
+        for i in range(self._wcp.channels()):
             axes.plot(
                 np.array(self._wcp.times(), copy=True),
                 np.array(self._wcp.values(record, i), copy=True),
--- ./myokit/gui/progress.py	(original)
+++ ./myokit/gui/progress.py	(refactored)
@@ -6,8 +6,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import division
-from __future__ import print_function
+
+
 import myokit
 from myokit.gui import Qt, QtCore, QtWidgets
 
--- ./myokit/gui/datablock_viewer.py	(original)
+++ ./myokit/gui/datablock_viewer.py	(refactored)
@@ -6,12 +6,12 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import division
+
 import os
 import numpy as np
 import traceback
 import collections
-import ConfigParser
+import configparser
 import myokit
 import myokit.gui
 from myokit.gui import QtWidgets, QtGui, QtCore, Qt
@@ -169,7 +169,7 @@
         self._variable_select.activated.connect(self.event_variable_selected)
         self._variable_select.setMinimumWidth(120)
         # Colormap selection
-        self._colormap = myokit.ColorMap.names().next()
+        self._colormap = next(myokit.ColorMap.names())
         self._colormap_select = QtWidgets.QComboBox()
         for cmap in myokit.ColorMap.names():
             self._colormap_select.addItem(cmap)
@@ -523,7 +523,7 @@
         self._menu_file.addSeparator()
         # File > Recent files
         self._recent_file_tools = []
-        for i in xrange(N_RECENT_FILES):
+        for i in range(N_RECENT_FILES):
             tool = QtWidgets.QAction(self, visible=False)
             tool.triggered.connect(self.action_recent_file)
             self._recent_file_tools.append(tool)
@@ -643,7 +643,7 @@
         inifile = os.path.expanduser(SETTINGS_FILE)
         if not os.path.isfile(inifile):
             return
-        config = ConfigParser.ConfigParser()
+        config = configparser.ConfigParser()
         config.read(inifile)
 
         # Window dimensions and location
@@ -829,7 +829,7 @@
         """
         Saves the user configuration to an ini file.
         """
-        config = ConfigParser.ConfigParser()
+        config = configparser.ConfigParser()
         # Window dimensions and location
         config.add_section('window')
         g = self.geometry()
@@ -865,7 +865,7 @@
             t.setText(str(k + 1) + '. ' + os.path.basename(fname))
             t.setData(fname)
             t.setVisible(True)
-        for i in xrange(len(self._recent_files), N_RECENT_FILES):
+        for i in range(len(self._recent_files), N_RECENT_FILES):
             self._recent_file_tools[i].setVisible(False)
 
     def update_window_title(self):
@@ -1112,10 +1112,10 @@
         yy = (self._data.trace(variable, x, y) - ymin) / (ymax - ymin)
         yy = iter(1 - yy)
         path = QtGui.QPainterPath()
-        x, y = xx.next(), yy.next()
+        x, y = next(xx), next(yy)
         path.moveTo(x, y)
-        for i in xrange(1, len(self._time)):
-            x, y = xx.next(), yy.next()
+        for i in range(1, len(self._time)):
+            x, y = next(xx), next(yy)
             path.lineTo(x, y)
         self._temp_index = index
         self._temp_path = path
@@ -1130,7 +1130,7 @@
         d = myokit.DataLog()
         if self._data:
             d['engine.time'] = self._data.time()
-            for index in self._frozen.iterkeys():
+            for index in self._frozen.keys():
                 x, y, variable = index
                 d[variable, x, y] = self._data.trace(variable, x, y)
             if self._temp_index:
@@ -1171,12 +1171,12 @@
         pen.setWidth(0)
         # Draw frozen graphs
         colors = iter(self._color_cycle)
-        for path in self._frozen.itervalues():
+        for path in self._frozen.values():
             try:
-                pen.setColor(colors.next())
+                pen.setColor(next(colors))
             except StopIteration:
                 colors = iter(self._color_cycle)
-                pen.setColor(colors.next())
+                pen.setColor(next(colors))
             painter.setPen(pen)
             painter.drawPath(path)
         # Draw temp graph
--- ./myokit/gui/vargrapher.py	(original)
+++ ./myokit/gui/vargrapher.py	(refactored)
@@ -9,8 +9,8 @@
 #  See: http://myokit.org
 #
 # Future stuff
-from __future__ import division
-from __future__ import print_function
+
+
 # Standard library imports
 # Myokit
 import myokit
--- ./myokit/gui/source.py	(original)
+++ ./myokit/gui/source.py	(refactored)
@@ -8,8 +8,8 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import division
-from __future__ import print_function
+
+
 import myokit
 from myokit.gui import Qt, QtCore, QtGui, QtWidgets
 
@@ -231,11 +231,11 @@
                 cursor.beginEditBlock()     # Undo grouping
                 doc = self.document()
                 b = doc.findBlock(start)
-                e = doc.findBlock(end).next()
+                e = next(doc.findBlock(end))
                 while b != e:
                     cursor.setPosition(b.position())
                     cursor.insertText(TABS * SPACE)
-                    b = b.next()
+                    b = next(b)
                 cursor.endEditBlock()
             else:
                 # Insert spaces until next tab stop
@@ -281,7 +281,7 @@
                     new_start -= p
                 new_end -= p
                 q += p
-                b = b.next()
+                b = next(b)
             last = b.previous()
             new_start = max(new_start, first.position())
             new_end = max(new_end, new_start)
@@ -485,7 +485,7 @@
             if block.isVisible() and bbot >= etop:
                 painter.drawText(
                     0, btop, width, height, Qt.AlignRight, str(count))
-            block = block.next()
+            block = next(block)
             btop = bbot
             bbot += self.blockBoundingRect(block).height()
 
@@ -605,7 +605,7 @@
         block = first
         blocks = [first]
         while block != last:
-            block = block.next()
+            block = next(block)
             blocks.append(block)
         lines = [block.text() for block in blocks]
         indent = [len(t) - len(t.lstrip()) for t in lines if len(t) > 0]
@@ -653,7 +653,7 @@
                 cursor.setPosition(
                     block.position() + a, QtGui.QTextCursor.KeepAnchor)
                 cursor.removeSelectedText()
-            block = block.next()
+            block = next(block)
         cursor.endEditBlock()
 
 
--- ./myokit/lib/approx.py	(original)
+++ ./myokit/lib/approx.py	(refactored)
@@ -8,7 +8,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import division
+
 import os
 import myokit
 import numpy as np
@@ -98,7 +98,7 @@
 
         def f(x):
             v = c[-1]
-            for i in xrange(n - 2, -1, -1):
+            for i in range(n - 2, -1, -1):
                 v = v * x + c[i]
             return v
         self._func = f
@@ -192,7 +192,7 @@
             def f(x):
                 cond = [0] * n
                 cond[0] = x < k[0]
-                for i in xrange(0, n - 2):
+                for i in range(0, n - 2):
                     cond[i + 1] = (x >= k[i]) * (x < k[i + 1])
                 cond[-1] = x >= k[-1]
                 return np.piecewise(x, cond, self._p)
@@ -223,7 +223,7 @@
         if n == 0:
             return Polynomial(c[0]).myokit_form(lhs)
         args = [lhs.clone()]
-        for i in xrange(0, n):
+        for i in range(0, n):
             args.append(p[i].myokit_form(lhs))
             args.append(myokit.Number(self._k[i]))
         args.append(p[n].myokit_form(lhs))
@@ -363,14 +363,14 @@
 
     # Calculate lagrange polynomial coefficients and return
     c = np.zeros(n + 1)
-    for k in xrange(0, n + 1):
+    for k in range(0, n + 1):
         p = np.array(list(x[0:k]) + list(x[k + 1:n + 1]))
         q = np.zeros(n + 1)
         q[-1] = 1
         q[-2] -= p[0]
         r = f(x[k]) / (x[k] - p[0])
-        for i in xrange(1, n):
-            for j in xrange(i, 0, -1):
+        for i in range(1, n):
+            for j in range(i, 0, -1):
                 q[-j - 2] -= p[i] * q[-j - 1]
             q[-2] -= p[i]
             r /= x[k] - p[i]
@@ -436,12 +436,12 @@
 
     # Iterate
     e_last = None
-    for k in xrange(0, max_iter):
+    for k in range(0, max_iter):
         # Build linear system and solve to find coefficients
-        for i in xrange(0, n + 2):
+        for i in range(0, n + 2):
             A[i, 0] = -1 if i % 2 else 1
             A[i, 2] = x[i]
-            for j in xrange(1, n):
+            for j in range(1, n):
                 A[i, 2 + j] = A[i, 1 + j] * x[i]
         B = f(x)
         C = solve(A, B)
@@ -471,7 +471,7 @@
         # Find roots of error function in intervals between points
         def E(t):
             return g(t) - f(t)
-        for i in xrange(0, n + 1):
+        for i in range(0, n + 1):
             z[i] = brentq(E, x[i], x[i + 1])
 
         # Find points of maximum deviation between these roots, use as new x
@@ -479,7 +479,7 @@
             return -(g(t) - f(t)) * (g(t) - f(t))
         x[0] = fmin(E, x[0], a, z[0])
         x[n + 1] = fmin(E, x[n + 1], z[n], b)
-        for i in xrange(1, n + 1):
+        for i in range(1, n + 1):
             x[i] = fmin(E, x[i], z[i - 1], z[i])
 
     # Return result
@@ -513,13 +513,13 @@
     A[0, 1] = h[0]
     A[-1, -1] = 2 * h[-1]
     A[-1, -2] = h[-1]
-    for i in xrange(1, n - 1):
+    for i in range(1, n - 1):
         A[i, i - 1:i + 2] = h[i - 1], 2 * (h[i - 1] + h[i]), h[i]
     F = f(p)
     B = np.zeros(n)
     B[0] = 3 / h[0] * (F[1] - F[0]) - 3 * f1a
     B[-1] = -3 / h[-1] * (F[-1] - F[-2]) + 3 * f1b
-    for i in xrange(1, n - 1):
+    for i in range(1, n - 1):
         B[i] = 3 / h[i] * (F[i + 1] - F[i]) - 3 / h[i - 1] * (F[i] - F[i - 1])
     Z = np.linalg.solve(A, B)
     # Now, create matrix with the polynomial coeffs of the splines
@@ -527,11 +527,11 @@
     C = np.zeros((n - 1, 4))
     C[0:, 0] = F[0:-1]
     C[0:, 2] = Z[0:-1]
-    for i in xrange(n - 2, -1, -1):
+    for i in range(n - 2, -1, -1):
         C[i, 1] = (F[i + 1] - F[i]) / h[i] - (h[i] / 3) * (2 * Z[i] + Z[i + 1])
         C[i, 3] = (Z[i + 1] - Z[i]) / (3 * h[i])
     # Rework the coefficients so that "x" can be used instead of "(x-p)"
-    for i in xrange(0, n - 1):
+    for i in range(0, n - 1):
         p1 = p[i]
         p2 = p1 * p1
         C[i, 0] -= C[i, 1] * p1 - C[i, 2] * p2 + C[i, 3] * p2 * p1
@@ -583,7 +583,7 @@
     H = np.max(F) - np.min(F)
     # Attempt fit
     k = np.linspace(lo, up, 1 + min_pieces)    # Because #knots = #pieces + 1
-    for i in xrange(min_pieces, 1 + max_pieces):
+    for i in range(min_pieces, 1 + max_pieces):
         g = solve_cubic_spline(f, k)
         # Get max deviation, position of max deviation
         a = np.abs(F - g(X))
@@ -650,7 +650,7 @@
             raise ValueError(
                 'The given variable must be a variable in the given model.')
     else:
-        if type(var) in [str, unicode]:
+        if type(var) in [str, str]:
             lhs = myokit.Name(model.get(var))
         elif isinstance(var, myokit.Variable):
             lhs = myokit.Name(var)
@@ -678,7 +678,7 @@
     # Iterate over variables, attempt to find suitable functions
     functions = []
     for v, deps in model.map_deep_dependencies(
-            omit_states=False, filter_encompassed=True).iteritems():
+            omit_states=False, filter_encompassed=True).items():
         # Exclude blacklisted lhs expressions
         if v in blacklist:
             continue
@@ -748,7 +748,7 @@
             var = model.get(var.var().qname())
             lhs = myokit.Name(var)
         else:
-            if type(var) in [str, unicode]:
+            if type(var) in [str, str]:
                 lhs = myokit.Name(model.get(var))
             elif isinstance(var, myokit.Variable):
                 # Get equivalent variable from cloned model
@@ -846,7 +846,7 @@
             # Attempt fits of increasing order
             fit = g = deviation = None
             try:
-                for n in xrange(2, 1 + self._max_order):
+                for n in range(2, 1 + self._max_order):
                     c, g, e = fit_remez_polynomial(f, rng, n)
                     deviation = e / H
                     if deviation < self._reltol:
@@ -910,7 +910,7 @@
             else:
                 self.log('No suitable approximation found.')
         # Create updated model
-        for var, fit in fits.iteritems():
+        for var, fit in fits.items():
             var.set_rhs(fit)
             var.meta['approximate'] = 'polynomial'
             self._changed.append(var.qname())
@@ -1067,7 +1067,7 @@
             else:
                 self.log('No suitable approximation found.')
         # Create updated model
-        for var, fit in fits.iteritems():
+        for var, fit in fits.items():
             var.set_rhs(fit)
             var.meta['approximate'] = 'cubic_spline'
             self._changed.append(var.qname())
@@ -1089,7 +1089,7 @@
     PolynomialFitter,
     CubicSplineFitter,
 ]
-FITTERS = dict(zip([x.name for x in FITTERS], FITTERS))
+FITTERS = dict(list(zip([x.name for x in FITTERS], FITTERS)))
 del(x)
 
 
--- ./myokit/lib/common.py	(original)
+++ ./myokit/lib/common.py	(refactored)
@@ -22,7 +22,7 @@
         self._model = model.clone()
         # Get variable names
         self._vars = []
-        if type(var) in [str, unicode] or isinstance(var, myokit.Variable):
+        if type(var) in [str, str] or isinstance(var, myokit.Variable):
             var = [var]
         for v in var:
             if isinstance(v, myokit.Variable):
@@ -275,7 +275,7 @@
         if factor is None:
             factor = np.ones(len(self._steps))
         for k, log in enumerate(self._logs):
-            v = steps.next()
+            v = next(steps)
             d = myokit.DataLog()
             for var in self._vars:
                 d[var] = np.array(log[var]) * factor[k]
@@ -471,7 +471,7 @@
         self._tvar = self._model.time()
         # Check conductance variables
         self._vars = []
-        if type(var) in [str, unicode] or isinstance(var, myokit.Variable):
+        if type(var) in [str, str] or isinstance(var, myokit.Variable):
             var = [var]
         for v in var:
             if isinstance(v, myokit.Variable):
@@ -925,7 +925,7 @@
         # Test every duration
         for k, duration in enumerate(durations):
             if debug:
-                print('Testing duration: ' + str(duration))
+                print(('Testing duration: ' + str(duration)))
             s.set_protocol(myokit.pacing.blocktrain(self._time + 1, duration))
             a1 = self._amin
             a2 = self._amax
@@ -952,7 +952,7 @@
                     traceback.print_exc()
                 t2 = False
             if debug:
-                print t2
+                print(t2)
             if t1 == t2:
                 # No zero crossing found
                 amplitudes[k] = np.nan
@@ -961,7 +961,7 @@
                 continue
             # Zero must lie in between. Start bisection search
             a = 0.5 * a1 + 0.5 * a2
-            for j in xrange(0, self._precision):
+            for j in range(0, self._precision):
                 s.reset()
                 s.set_constant(self._avar, a)
                 try:
@@ -978,7 +978,7 @@
                 a = 0.5 * a1 + 0.5 * a2
             amplitudes[k] = a
             if debug:
-                print('> ' + str(a))
+                print(('> ' + str(a)))
         # Set output data
         self._data = myokit.DataLog()
         self._data['duration'] = durations
--- ./myokit/lib/deps.py	(original)
+++ ./myokit/lib/deps.py	(refactored)
@@ -43,10 +43,10 @@
     # Create two copies of dependency matrix, apply knockouts
     p = []
     q = []
-    for i in xrange(0, n):
+    for i in range(0, n):
         pp = []
         qq = []
-        for j in xrange(0, n):
+        for j in range(0, n):
             v = m[i][j] if s[i] not in knockout else 0
             pp.append(v)
             qq.append(v)
@@ -57,19 +57,19 @@
     # At the end of each iteration, q is copied into p
     # At the end of this operation, p = q = the distances
     # Repeat this trick n-1 times...
-    for index in xrange(1, n):
-        for i in xrange(0, n):
-            for j in xrange(0, n):
+    for index in range(1, n):
+        for i in range(0, n):
+            for j in range(0, n):
                 # ... for every item
                 if p[i][j] == index:
                     # ... where the value is the current index 1,2,3...
-                    for k in xrange(0, n):
+                    for k in range(0, n):
                         # ... update the entries
                         # ... unless a previous value was set
                         if q[i][k] == 0 and p[j][k] > 0:
                             q[i][k] = p[i][j] + p[j][k]
-        for i in xrange(0, n):
-            for j in xrange(0, n):
+        for i in range(0, n):
+            for j in range(0, n):
                 p[i][j] = q[i][j]
     return p
 
@@ -130,11 +130,11 @@
             verticalalignment='center')
     # Set tick labels
     names = [i.qname() for i in model.states()]
-    a.set_xticks([i + 0.5 for i in xrange(0, n)])
+    a.set_xticks([i + 0.5 for i in range(0, n)])
     a.set_xticklabels(names)
     from matplotlib.transforms import Affine2D
     r = Affine2D.identity()
-    a.set_yticks([i + 0.5 for i in xrange(0, n)])
+    a.set_yticks([i + 0.5 for i in range(0, n)])
     rnames = list(names)
     rnames.reverse()
     a.set_yticklabels(rnames)
@@ -181,7 +181,7 @@
         return len(self.nodes)
 
     def __iter__(self):
-        return self.nodes.itervalues()
+        return iter(self.nodes.values())
 
     def __getitem__(self, key):
         return self.nodes.__getitem__(key)
@@ -230,16 +230,16 @@
             if n != len(self.nodes):
                 raise ValueError('Matrix must have same size as graph.')
             # Clear existing edges
-            for node in self.nodes.itervalues():
+            for node in self.nodes.values():
                 node.clear_edges()
         else:
             # Delete nodes
             self.nodes = collections.OrderedDict()
             # Create nodes
-            for i in xrange(n):
+            for i in range(n):
                 self.add_node(i)
         # Add edges
-        nodes = self.nodes.values()
+        nodes = list(self.nodes.values())
         for i, row in enumerate(matrix):
             for j, edge in enumerate(row):
                 if edge:
@@ -308,7 +308,7 @@
             try:
                 v = 0
                 while v == 0:
-                    v = ni.next() - mi.next()
+                    v = next(ni) - next(mi)
                 return v < 0
             except StopIteration:
                 return len(n) < len(m)
@@ -332,7 +332,7 @@
                 'Graph is not acyclical: no node without successors found.')
         P[first] = 1
         # Assign remaining orders
-        for i in xrange(2, n + 1):
+        for i in range(2, n + 1):
             kmin = None
             nmin = None
             for node in graph:
@@ -386,13 +386,13 @@
         """
         m = self.path_matrix()
         n = len(m)
-        for i in xrange(n):
+        for i in range(n):
             if m[i][i]:
                 raise Exception('Graph is not acyclical.')
-        for j in xrange(n):
-            for i in xrange(n):
+        for j in range(n):
+            for i in range(n):
                 if m[i][j]:
-                    for k in xrange(n):
+                    for k in range(n):
                         if m[j][k]:
                             m[i][k] = 0
         graph = DiGraph(self)
@@ -403,12 +403,12 @@
         """
         Returns a connectivity matrix for this graph.
         """
-        nodes = self.nodes.values()
+        nodes = list(self.nodes.values())
         n = len(nodes)
         m = [0] * n
         for i, node in enumerate(nodes):
             row = [0] * n
-            for j in xrange(0, n):
+            for j in range(0, n):
                 if node.has_edge_to(nodes[j]):
                     row[j] = 1
             m[i] = row
@@ -429,12 +429,12 @@
         """
         p = self.matrix()
         n = len(p)
-        for i in xrange(0, n):
-            for j in xrange(0, n):
+        for i in range(0, n):
+            for j in range(0, n):
                 if i == j:
                     continue
                 if p[j][i]:
-                    for k in xrange(0, n):
+                    for k in range(0, n):
                         if p[j][k] == 0:
                             p[j][k] = p[i][k]
             return p
@@ -452,7 +452,7 @@
         else:
             if self.nodes:
                 out = []
-                for node in self.nodes.itervalues():
+                for node in self.nodes.values():
                     out.append('Node "' + node.label() + '"')
                     for edge in node.edgo:
                         out.append('  > Node "' + edge.label() + '"')
@@ -483,7 +483,7 @@
                     node.x = j * fx
         # Iteratively update x coordinates using median rule
         max_runs = 100
-        for n_runs in xrange(max_runs):
+        for n_runs in range(max_runs):
             change = False
             for i, layer in enumerate(layers):
                 # Set nodes to median of neighbours
@@ -522,7 +522,7 @@
                             x1 = 0.0 if j == 1 else layer[j - 2].x
                             # Get next x
                             x2 = None
-                            for k in xrange(j + 1, n):
+                            for k in range(j + 1, n):
                                 if abs(layer[k].x - node.x) >= too_close:
                                     x2 = layer[k].x
                                     break
@@ -735,7 +735,7 @@
         node.label = c.name()
     # Add edges, get sorted dict of nodes sorted by #deps
     order = {}
-    for c, cdeps in deps.iteritems():
+    for c, cdeps in deps.items():
         n = 0
         for d in cdeps:
             g.add_edge(c, d)
@@ -755,7 +755,7 @@
         if False:
             dy = -dy
             y = 1 - y
-        for key in sorted(order.iterkeys()):
+        for key in sorted(order.keys()):
             level = order[key]
             nLevel = len(level)
             dx = (1 - 2 * p) / (nLevel - 1) if nLevel > 1 else 0
@@ -792,7 +792,7 @@
     deps = model.map_shallow_dependencies(
         collapse=True, omit_states=True, omit_constants=True)
     # Create nodes
-    for lhs, dps in deps.iteritems():
+    for lhs, dps in deps.items():
         # Create node
         node = g.add_node(lhs)
         # Set node label
@@ -803,7 +803,7 @@
         node.rgba = (random.random(), random.random(), random.random(), 0.9)
     # Create edges
     used = set()
-    for lhs, dps in deps.iteritems():
+    for lhs, dps in deps.items():
         for dep in dps:
             g.add_edge(lhs, dep)
             used.add(lhs)
--- ./myokit/gui/ide.py	(original)
+++ ./myokit/gui/ide.py	(refactored)
@@ -8,12 +8,12 @@
 #  See: http://myokit.org
 #
 # Future stuff
-from __future__ import division
+
 # Standard library imports
 import gc
 import os
 import traceback
-import ConfigParser
+import configparser
 # Myokit
 import myokit
 import myokit.formats
@@ -22,10 +22,10 @@
 from myokit.gui import QtWidgets, QtGui, QtCore, Qt
 # GUI components
 import myokit.gui
-import source
-import explorer
-import progress
-import vargrapher
+from . import source
+from . import explorer
+from . import progress
+from . import vargrapher
 # Matplotlib imports
 # Matplotlib.pyplot must be imported _after_ myokit.gui has set the backend
 import matplotlib
@@ -1308,7 +1308,7 @@
         self._menu_file.addSeparator()
         # File > Recent files
         self._recent_file_tools = []
-        for i in xrange(N_RECENT_FILES):
+        for i in range(N_RECENT_FILES):
             tool = QtWidgets.QAction(self, visible=False)
             tool.triggered.connect(self.action_open_recent)
             self._recent_file_tools.append(tool)
@@ -1704,7 +1704,7 @@
         inifile = os.path.expanduser(SETTINGS_FILE)
         if not os.path.isfile(inifile):
             return
-        config = ConfigParser.ConfigParser()
+        config = configparser.ConfigParser()
         config.read(inifile)
 
         def getor(section, name, alt):
@@ -1965,7 +1965,7 @@
         """
         Saves the user configuration to an ini file.
         """
-        config = ConfigParser.ConfigParser()
+        config = configparser.ConfigParser()
         # Window dimensions and location
         config.add_section('window')
         g = self.geometry()
@@ -2141,7 +2141,7 @@
             t.setStatusTip('Open ' + os.path.abspath(filename))
             t.setData(filename)
             t.setVisible(True)
-        for i in xrange(len(self._recent_files), N_RECENT_FILES):
+        for i in range(len(self._recent_files), N_RECENT_FILES):
             self._recent_file_tools[i].setVisible(False)
 
     def update_window_title(self):
--- ./myokit/gui/gde.py	(original)
+++ ./myokit/gui/gde.py	(refactored)
@@ -20,8 +20,8 @@
 # signals to allow undo/redo and listeners. In the cases where this is not
 # desired, the silent_ methods can be used.
 #
-from __future__ import print_function
-from __future__ import division
+
+
 import math
 import os.path
 import traceback
@@ -29,7 +29,7 @@
 import collections
 import xml.dom.minidom as minidom
 import xml.etree.cElementTree as et
-import ConfigParser as configparser
+import configparser as configparser
 import myokit.gui
 from myokit.gui import Qt, QtCore, QtGui, QtWidgets
 
@@ -240,14 +240,14 @@
 
         **Required to work with DocumentModel.**
         """
-        return self._kids[self._kids.keys()[k]]
+        return self._kids[list(self._kids.keys())[k]]
 
     def clear_selection(self):
         """
         Clears the selection (if any) of this node and any children nodes.
         """
         self.deselect()
-        for kid in self._kids.itervalues():
+        for kid in self._kids.values():
             kid.clear_selection()
 
     def deselect(self):
@@ -346,9 +346,9 @@
         """
         e = et.Element(self._ntype)
         e.attrib['name'] = self._name
-        for d in self._data.itervalues():
+        for d in self._data.values():
             e.append(d.get_xml())
-        for k in self._kids.itervalues():
+        for k in self._kids.values():
             e.append(k.get_xml())
         return e
 
@@ -366,7 +366,7 @@
         """
         if self._parent is None:
             return 0
-        return self._parent._kids.values().index(self)
+        return list(self._parent._kids.values()).index(self)
 
     def is_selected(self):
         """
@@ -378,14 +378,14 @@
         """
         Returns an iterator over this node's children.
         """
-        return self._kids.itervalues()
+        return iter(self._kids.values())
 
     def iterdata(self):
         """
         Returns an iterator over the :class:`DocumentValue` objects stored in
         this node.
         """
-        return self._data.itervalues()
+        return iter(self._data.values())
 
     def __len__(self):
         """
@@ -393,7 +393,7 @@
         """
         return len(self._kids)
 
-    def __nonzero__(self):
+    def __bool__(self):
         """
         Used when writing ``if node:``, without overloading this, the
         value of ``__len__`` would be used in these cases.
@@ -692,7 +692,7 @@
         self._node = node
         self._vtype = vtype
         self._name = name
-        if type(value) in (str, unicode):
+        if type(value) in (str, str):
             self._value = self._value_from_string(value)
         else:
             self._value = value
@@ -731,7 +731,7 @@
         """
         Changes this variable's value.
         """
-        if type(value) in (str, unicode):
+        if type(value) in (str, str):
             value = self._value_from_string(value)
         action = DA_ChangeVariable(self, value)
         return self.get_node().get_document()._perform(action)
@@ -751,7 +751,7 @@
         Changes this variable's data type, without using actions or sending
         signals.
         """
-        if type(value) in (str, unicode):
+        if type(value) in (str, str):
             value = self._value_from_string(value)
         self._value = value
 
@@ -887,10 +887,10 @@
                 # Write data
                 with open(path, 'w') as f:
                     f.write(header)
-                    for i in xrange(sam):
+                    for i in range(sam):
                         f.write(
-                            fmt.format(x.next()) + ','
-                            + fmt.format(y.next()) + '\n')
+                            fmt.format(next(x)) + ','
+                            + fmt.format(next(y)) + '\n')
             else:
                 with open(path, 'w') as f:
                     f.write(header)
@@ -1715,17 +1715,17 @@
     def _perform(self):
         if self.old_variables is None:
             self.old_variables = {}
-            for name, value in self.variables.iteritems():
+            for name, value in self.variables.items():
                 self.old_variables[name] = \
                     self.node.get_variable(name).get_value()
-        for name, value in self.variables.iteritems():
+        for name, value in self.variables.items():
             var = self.node.get_variable(name)
             var.silent_set_value(value)
             self.node.variable_changed.emit(self.node, var)
             var.variable_changed.emit(var)
 
     def _undo(self):
-        for name, value in self.old_variables.iteritems():
+        for name, value in self.old_variables.items():
             var = self.node.get_variable(name)
             var.silent_set_value(value)
             self.node.variable_changed.emit(self.node, var)
@@ -2181,7 +2181,7 @@
         self._menu_file.addSeparator()
         # File > Recent files
         self._recent_file_tools = []
-        for i in xrange(N_RECENT_FILES):
+        for i in range(N_RECENT_FILES):
             tool = QtWidgets.QAction(self, visible=False)
             tool.triggered.connect(self.action_open_recent)
             self._recent_file_tools.append(tool)
@@ -2454,7 +2454,7 @@
             t.setText(str(k + 1) + '. ' + os.path.basename(filename))
             t.setData(filename)
             t.setVisible(True)
-        for i in xrange(len(self._recent_files), N_RECENT_FILES):
+        for i in range(len(self._recent_files), N_RECENT_FILES):
             self._recent_file_tools[i].setVisible(False)
 
     def update_window_title(self):
@@ -2830,7 +2830,7 @@
             self._yaxis.disconnect()
             #for item in self._data.itervalues():
             #    item.disconnect()
-            for item in self._sets.itervalues():
+            for item in self._sets.values():
                 item.disconnect()
         # Child items will disconnect when deleted by refcount decrease.
         self._image = None
@@ -3635,9 +3635,9 @@
         # Create path
         path = QtGui.QPainterPath()
         x, y = iter(x2), iter(y2)
-        path.moveTo(*scene.norm2scene(x.next(), y.next()))
-        for i in xrange(1, sam):
-            path.lineTo(*scene.norm2scene(x.next(), y.next()))
+        path.moveTo(*scene.norm2scene(next(x), next(y)))
+        for i in range(1, sam):
+            path.lineTo(*scene.norm2scene(next(x), next(y)))
         self._path = path
         # Redraw
         self.update()
--- ./myokit/lib/plots.py	(original)
+++ ./myokit/lib/plots.py	(refactored)
@@ -7,7 +7,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import division
+
 import numpy as np
 # Don't import pyplot yet, this will cause a crash if no window environment
 # is loaded.
@@ -91,7 +91,7 @@
         bucket_x = np.zeros(nbuckets)
         bucket_y = np.zeros(nbuckets)
         hi = zero
-        for k in xrange(nbuckets):
+        for k in range(nbuckets):
             lo = hi
             hi = zero + (k + 1) * bucket_w
             bucket_x[k] = lo
@@ -129,7 +129,7 @@
     except KeyError:
         raise ValueError(
             'Selected mode not found. Avaiable modes are: '
-            + ', '.join(['"' + x + '"' for x in modes.iterkeys()]))
+            + ', '.join(['"' + x + '"' for x in modes.keys()]))
     return fn(axes, time, realtime, evaluations)
 
 
--- ./play/command.py	(original)
+++ ./play/command.py	(refactored)
@@ -42,4 +42,4 @@
         
 class X(SubCommand):
     def run(self, x, y):
-        print(x, y)
+        print((x, y))
--- ./myokit/lib/fit.py	(original)
+++ ./myokit/lib/fit.py	(refactored)
@@ -22,13 +22,13 @@
 # The remaining algorithsm and optimisation routines are original
 # implementations, and try to credit the algorithm's authors were possible.
 #
-from __future__ import division
-from __future__ import print_function
+
+
 import gc
 import os
 import sys
 import time
-import Queue
+import queue
 import traceback
 import multiprocessing
 import numpy as np
@@ -290,7 +290,7 @@
     if not verbose:
         options.set('verbose', -9)
     # Start one or multiple runs
-    for i in xrange(1 + ipop):
+    for i in range(1 + ipop):
         # Set population size, increase for ipop restarts
         options.set('popsize', n)
         if verbose:
@@ -590,7 +590,7 @@
     x = []
     n = iter(npoints)
     for xmin, xmax in bounds:
-        x.append(np.linspace(xmin, xmax, n.next()))
+        x.append(np.linspace(xmin, xmax, next(n)))
     # Create a grid from these points
     x = np.array(np.meshgrid(*x, indexing='ij'))
     # Re-organise the grid to be a series of nd-dimensional points
@@ -788,7 +788,7 @@
         Cleans up any dead workers & return the number of workers tidied up.
         """
         cleaned = 0
-        for k in xrange(len(self._workers) - 1, -1, -1):
+        for k in range(len(self._workers) - 1, -1, -1):
             w = self._workers[k]
             if w.exitcode is not None:
                 w.join()
@@ -802,7 +802,7 @@
         """
         Populates (but usually repopulates) the worker pool.
         """
-        for k in xrange(self._nworkers - len(self._workers)):
+        for k in range(self._nworkers - len(self._workers)):
             w = _Worker(
                 self._function,
                 self._args,
@@ -844,7 +844,7 @@
                         i, f = self._results.get(block=False)
                         results[i] = f
                         m += 1
-                except Queue.Empty:
+                except queue.Empty:
                     pass
                 # Clean dead workers
                 if self._clean():
@@ -903,7 +903,7 @@
             try:
                 while True:
                     items.append(queue.get(timeout=0.1))
-            except (Queue.Empty, IOError, EOFError):
+            except (queue.Empty, IOError, EOFError):
                 pass
             return items
         clear(self._tasks)
@@ -1240,7 +1240,7 @@
     # Initialize particles
     brange = upper - lower
     nhints = len(hints)
-    for i in xrange(n):
+    for i in range(n):
         if i < nhints:
             xs.append(hints[i])
         else:
@@ -1273,7 +1273,7 @@
     else:
         evaluator = SequentialEvaluator(function, args=args)
     # Start searching
-    for iteration in xrange(1, 1 + max_iter):
+    for iteration in range(1, 1 + max_iter):
         # Check target criterion
         if fg <= target:
             if verbose:
@@ -1287,7 +1287,7 @@
         else:
             fs = evaluator.evaluate(xs)
         # Update particles
-        for i in xrange(n):
+        for i in range(n):
             # Update best local position and score
             if fs[i] < fl[i]:
                 fl[i] = fs[i]
@@ -1471,8 +1471,8 @@
     # obtain the constants for the polynomial.
     R = np.zeros((m, m))
     k = 0
-    for i in xrange(1 + n):
-        for j in xrange(i, 1 + n):
+    for i in range(1 + n):
+        for j in range(i, 1 + n):
             R[:, k] = T[:, i] * T[:, j]
             k += 1
     p = np.linalg.solve(R, Y)
@@ -1485,7 +1485,7 @@
     # by n, such that y = A + B' * X + x' * D * x
     D = np.zeros((n, n))
     k = 1 + n
-    for i in xrange(n):
+    for i in range(n):
         D[i, i:n] = p[k:k + n - i].transpose()
         k += n - i
     # Now, C = D' + D
@@ -1759,9 +1759,9 @@
     if callback is not None:
         callback(np.array(hint, copy=True), fbest)
     # Start running
-    for iteration in xrange(1, 1 + max_iter):
+    for iteration in range(1, 1 + max_iter):
         # Create new samples
-        ss = np.array([np.random.normal(0, 1, d) for i in xrange(n)])
+        ss = np.array([np.random.normal(0, 1, d) for i in range(n)])
         xs = mu + sigmas * ss
         # Evaluate at the samples
         fxs = evaluator.evaluate(xs)
@@ -1916,7 +1916,7 @@
     *Note: This method requires SciPy to be installed.*
     """
     from scipy.spatial import Voronoi
-    from itertools import izip  # Like zip, but works as an iterator
+      # Like zip, but works as an iterator
 
     # Check x, y, f
     x = np.asarray(x)
@@ -1968,8 +1968,8 @@
     center = vor.points.mean(axis=0)
     radius2 = 2 * np.sqrt((xmax - xmin)**2 + (ymax - ymin)**2)
     # Create a list containing the set of vertices defining each region
-    regions = [set() for i in xrange(n)]
-    for (p1, p2), (v1, v2) in izip(vor.ridge_points, vor.ridge_vertices):
+    regions = [set() for i in range(n)]
+    for (p1, p2), (v1, v2) in zip(vor.ridge_points, vor.ridge_vertices):
         # Ensure only v1 can every be -1
         if v1 > v2:
             v1, v2 = v2, v1
@@ -2170,7 +2170,7 @@
         sys.stdout = open(os.devnull, 'w')
         sys.stderr = open(os.devnull, 'w')
         try:
-            for k in xrange(self._max_tasks):
+            for k in range(self._max_tasks):
                 i, x = self._tasks.get()
                 f = self._function(x, *self._args)
                 self._results.put((i, f))
@@ -2375,10 +2375,10 @@
     if callback is not None:
         callback(np.array(hint, copy=True), fbest)
     # Start running
-    for iteration in xrange(1, 1 + max_iter):
+    for iteration in range(1, 1 + max_iter):
         # Create new samples
-        zs = np.array([np.random.normal(0, 1, d) for i in xrange(n)])
-        xs = np.array([mu + np.dot(A, zs[i]) for i in xrange(n)])
+        zs = np.array([np.random.normal(0, 1, d) for i in range(n)])
+        xs = np.array([mu + np.dot(A, zs[i]) for i in range(n)])
         # Evaluate at the samples
         fxs = evaluator.evaluate(xs)
         # Order the normalized samples according to the scores
--- ./play/fit/cmaes.py	(original)
+++ ./play/fit/cmaes.py	(refactored)
@@ -106,9 +106,9 @@
 # Show solution
 print('Current solution:           Real values:')
 for k, v in enumerate(x):
-    print(myokit.strfloat(v) + '    ' + myokit.strfloat(real[k]))
+    print((myokit.strfloat(v) + '    ' + myokit.strfloat(real[k])))
     
 # Show score
-print('Score: ' + str(f))
-print('True score: ' + str(score(real)))
+print(('Score: ' + str(f)))
+print(('True score: ' + str(score(real))))
 
--- ./myokit/lib/markov.py	(original)
+++ ./myokit/lib/markov.py	(refactored)
@@ -6,7 +6,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import division
+
 import numpy as np
 import myokit
 
@@ -291,8 +291,8 @@
         n = len(self._states)
         A = []      # Ode matrix
         T = set()   # List of transitions
-        for i in xrange(n):
-            A.append([myokit.Number(0) for j in xrange(n)])
+        for i in range(n):
+            A.append([myokit.Number(0) for j in range(n)])
         for row, e in enumerate(expressions):
             # Scan terms
             for term in _list_terms(e):
@@ -317,7 +317,7 @@
                 if row != col:
                     T.add((col, row))   # A is mirrored
         # Create a parametrisable matrix for the current
-        B = [myokit.Number(0) for i in xrange(n)]
+        B = [myokit.Number(0) for i in range(n)]
         if self._current is not None:
             for term in _list_terms(current_expression):
                 state = None
@@ -339,8 +339,8 @@
         T = list(T)
         T.sort()
         R = []
-        for i in xrange(len(A)):
-            for j in xrange(len(A)):
+        for i in range(len(A)):
+            for j in range(len(A)):
                 if (i, j) in T:
                     R.append((i, j, A[j][i]))   # A is mirrored
         del(T)
@@ -371,7 +371,7 @@
         # TODO What's the difference between these two?
         # If the function version works, use that for python3 compatibility!
         # exec(code, globl, local)
-        exec code in globl, local
+        exec(code, globl, local)
         self._matrix_function = local['matrix_function']
         #
         # Create function to return list of transition rates
@@ -390,7 +390,7 @@
         globl = {'numpy': np}
         local = {}
         #exec(code, globl, local)
-        exec code in globl, local
+        exec(code, globl, local)
         self._rate_list_function = local['rate_list_function']
 
     def current(self):
@@ -821,7 +821,7 @@
         else:
             # Check existing log
             n = 2 + len(self._state) + (1 if self._has_current else 0)
-            if len(log.keys()) > n:
+            if len(list(log.keys())) > n:
                 raise ValueError('Invalid log: contains extra keys.')
             test = self._model.states()
             test.append(time_key)
@@ -1223,7 +1223,7 @@
                 log[key] = []
         else:
             # Check existing log
-            if len(log.keys()) > 2 + len(self._state):
+            if len(list(log.keys())) > 2 + len(self._state):
                 raise ValueError('Invalid log: contains extra keys.')
             try:
                 for key in [vm_key, time_key] + self._model.states():
@@ -1281,7 +1281,7 @@
                 log_states[i].append(x)
             n_steps += 1
             if debug:
-                print(t, state)
+                print((t, state))
             # Get lambdas
             lambdas = R * state[SI]
             # Get sum of lambdas
@@ -1300,7 +1300,7 @@
                 if rsum > transition:
                     break
             if debug:
-                print(str(t) + ': ' + str(SI[i]) + ' --> ' + str(SJ[i]))
+                print((str(t) + ': ' + str(SI[i]) + ' --> ' + str(SJ[i])))
             # Perform transition
             state[SI[i]] -= 1
             state[SJ[i]] += 1
@@ -1315,7 +1315,7 @@
         for i, r in enumerate(lambdas):
             if np.random.uniform(0, 1) < r:
                 if debug:
-                    print('Final: ' + str(SI[i]) + ' --> ' + str(SJ[i]))
+                    print(('Final: ' + str(SI[i]) + ' --> ' + str(SJ[i])))
                 # Perform transition
                 state[SI[i]] -= 1
                 state[SJ[i]] += 1
--- ./play/fit/snes.py	(original)
+++ ./play/fit/snes.py	(refactored)
@@ -106,9 +106,9 @@
 # Show solution
 print('Current solution:           Real values:')
 for k, v in enumerate(x):
-    print(myokit.strfloat(v) + '    ' + myokit.strfloat(real[k]))
+    print((myokit.strfloat(v) + '    ' + myokit.strfloat(real[k])))
     
 # Show score
-print('Score: ' + str(f))
-print('True score: ' + str(score(real)))
+print(('Score: ' + str(f)))
+print(('True score: ' + str(score(real))))
 
--- ./play/fit/xnes.py	(original)
+++ ./play/fit/xnes.py	(refactored)
@@ -106,9 +106,9 @@
 # Show solution
 print('Current solution:           Real values:')
 for k, v in enumerate(x):
-    print(myokit.strfloat(v) + '    ' + myokit.strfloat(real[k]))
+    print((myokit.strfloat(v) + '    ' + myokit.strfloat(real[k])))
     
 # Show score
-print('Score: ' + str(f))
-print('True score: ' + str(score(real)))
+print(('Score: ' + str(f)))
+print(('True score: ' + str(score(real))))
 
--- ./play/fit/pso.py	(original)
+++ ./play/fit/pso.py	(refactored)
@@ -107,9 +107,9 @@
 # Show solution
 print('Current solution:           Real values:')
 for k, v in enumerate(x):
-    print(myokit.strfloat(v) + '    ' + myokit.strfloat(real[k]))
+    print((myokit.strfloat(v) + '    ' + myokit.strfloat(real[k])))
     
 # Show score
-print('Score: ' + str(f))
-print('True score: ' + str(score(real)))
+print(('Score: ' + str(f)))
+print(('True score: ' + str(score(real))))
 
--- ./test/runner.py	(original)
+++ ./test/runner.py	(refactored)
@@ -40,16 +40,16 @@
 
         # Load and run
         try:
-            print('Loading ' + fn)
+            print(('Loading ' + fn))
             m, p, x = myokit.load(os.path.join(path, fn))
             try:
                 print('Running...')
                 myokit.run(m, p, x)
             except Exception:
-                print(traceback.format_exc())
+                print((traceback.format_exc()))
         except Exception:
             print('Unable to load.')
-            print(traceback.format_exc())
+            print((traceback.format_exc()))
         try:
             pl.close('all')
         except Exception:
@@ -58,9 +58,9 @@
         # Tidy up
         del(m, p, x)
         gc.collect()
-        print('-' * 70)
+        print(('-' * 70))
 
     if filename is not None and not found:
-        print('Unable to find file: ' + str(filename))
+        print(('Unable to find file: ' + str(filename)))
     else:
         print('Done!')
--- ./play/fit/aslanidi/aslanidi-2009-toy-data-fit.py	(original)
+++ ./play/fit/aslanidi/aslanidi-2009-toy-data-fit.py	(refactored)
@@ -121,7 +121,7 @@
         xbest = None
         fbest = float('inf')
         print('Running pso optimisation to get starting point')
-        for i in xrange(10):
+        for i in range(10):
             x, f = fit.pso(score, bounds, n=24, max_iter=250, parallel=True,
                 callback=cb)
             if f < fbest:
@@ -132,10 +132,10 @@
         x, f = fit.cmaes(score, bounds, hint=xbest, parallel=True,
             verbose=True)
 
-print('Final score: ' + str(f))
-print('Score at true solution: ' + str(score(real_values)))
+print(('Final score: ' + str(f)))
+print(('Score at true solution: ' + str(score(real_values))))
     
 # Show solution
 print('Current solution:           Real values:')
 for k, v in enumerate(x):
-    print(myokit.strfloat(v) + '    ' + myokit.strfloat(real_values[k]))
+    print((myokit.strfloat(v) + '    ' + myokit.strfloat(real_values[k])))
--- ./test/myotest/__init__.py	(original)
+++ ./test/myotest/__init__.py	(refactored)
@@ -13,8 +13,8 @@
 import unittest
 
 # Dedicated test classes
-from _ansic_event_based_pacing import AnsicEventBasedPacing
-from _ansic_fixed_form_pacing import AnsicFixedFormPacing
+from ._ansic_event_based_pacing import AnsicEventBasedPacing
+from ._ansic_fixed_form_pacing import AnsicFixedFormPacing
 
 
 # Set this to True to debug the tests
@@ -55,7 +55,7 @@
                 name = fn[:-3]
                 mod = __import__(name, globals(), locals(), ['suite'])
                 if 'suite' in dir(mod):
-                    print('    ' + name)
+                    print(('    ' + name))
             return False
         else:
             return run(*args)
@@ -67,17 +67,17 @@
     """
     Runs selected tests.
     """
-    print('Scanning for tests: ' + ', '.join([str(x) for x in tests]))
+    print(('Scanning for tests: ' + ', '.join([str(x) for x in tests])))
     suite = unittest.TestSuite()
     for name in tests:
         path = os.path.join(DIR_TEST, name + '.py')
         try:
             mod = __import__(name, globals(), locals(), ['suite'])
         except ImportError:
-            print('Test <' + name + '> not found.')
+            print(('Test <' + name + '> not found.'))
             continue
         if not 'suite' in dir(mod):
-            print('Test <' + name + '> has no method suite().')
+            print(('Test <' + name + '> has no method suite().'))
             continue
         suite.addTests(mod.suite())
     print('Running selected tests')
@@ -97,7 +97,7 @@
         name = fn[:-3]
         mod = __import__(name, globals(), locals(), ['suite'])
         if 'suite' in dir(mod):
-            print('Adding ' + name)
+            print(('Adding ' + name))
             suite.addTests(mod.suite())
     print('Running all tests')
     result = unittest.TextTestRunner().run(suite)
--- ./test/myotest/_ansic_event_based_pacing.py	(original)
+++ ./test/myotest/_ansic_event_based_pacing.py	(refactored)
@@ -31,8 +31,8 @@
         fname = os.path.join(myotest.DIR_TEST, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(self._code(fname, args,
-                line_numbers=myokit.DEBUG_LINE_NUMBERS))
+            print((self._code(fname, args,
+                line_numbers=myokit.DEBUG_LINE_NUMBERS)))
             import sys
             sys.exit(1)
         # Create back-end
--- ./test/myotest/_ansic_fixed_form_pacing.py	(original)
+++ ./test/myotest/_ansic_fixed_form_pacing.py	(refactored)
@@ -30,8 +30,8 @@
         fname = os.path.join(myotest.DIR_TEST, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(self._code(fname, args,
-                line_numbers=myokit.DEBUG_LINE_NUMBERS))
+            print((self._code(fname, args,
+                line_numbers=myokit.DEBUG_LINE_NUMBERS)))
             import sys
             sys.exit(1)
         # Create back-end
--- ./play/openmp/openmp.py	(original)
+++ ./play/openmp/openmp.py	(refactored)
@@ -121,8 +121,8 @@
         fname = os.path.join(myokit.DIR_CFUNC, SOURCE_FILE)
         # Debug
         if myokit.DEBUG:
-            print(self._code(fname, args,
-                line_numbers=myokit.DEBUG_LINE_NUMBERS))
+            print((self._code(fname, args,
+                line_numbers=myokit.DEBUG_LINE_NUMBERS)))
             import sys
             sys.exit(1)
         # Create simulation
--- ./test/myotest/datablock.py	(original)
+++ ./test/myotest/datablock.py	(refactored)
@@ -113,7 +113,7 @@
         w = 8   # Points in space
         t = np.arange(n)
         log['time'] = t
-        for i in xrange(w):
+        for i in range(w):
             log['x', i] = i * t
             log['y', i] = i * t * 10
         # Create datablock
@@ -220,8 +220,8 @@
         self.assertEqual(b.len0d(), 0)
         self.assertEqual(b.len2d(), 1)
         x = b.get2d('x')
-        for xx in xrange(2):
-            for yy in xrange(3):
+        for xx in range(2):
+            for yy in range(3):
                 self.assertTrue(np.all(x[:,yy,xx] == log['x',xx,yy]))
         # Make bigger log, try again
         log['pace'] = np.ones(t.shape) + t**2
@@ -242,8 +242,8 @@
         self.assertFalse(b.get0d('pace') is log['pace'])
         x = b.get2d('x')
         y = b.get2d('y')
-        for xx in xrange(2):
-            for yy in xrange(3):
+        for xx in range(2):
+            for yy in range(3):
                 self.assertTrue(np.all(x[:,yy,xx] == log['x',xx,yy]))
                 self.assertTrue(np.all(y[:,yy,xx] == log['y',xx,yy]))
         # Test reading and writing
--- ./test/myotest/pacing.py	(original)
+++ ./test/myotest/pacing.py	(refactored)
@@ -337,7 +337,7 @@
             pacing = myotest.AnsicFixedFormPacing(list(t), list(v))
             b = myokit.Benchmarker()
             v2 = [pacing.pace(x) for x in t2]
-            print(b.time())
+            print((b.time()))
             # Plot the new points
             pl.plot(t2, v2, '.', color='green')
             pl.show()
@@ -357,10 +357,10 @@
         # Test with small lists
         values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
         times  = [0, 0, 1, 1, 1, 2, 2, 2, 3, 4,  5,  7]
-        values = range(len(times))
+        values = list(range(len(times)))
         pacing = myotest.AnsicFixedFormPacing(times, values)
         def test(value, index):
-            self.assertEquals(pacing.pace(value), index)
+            self.assertEqual(pacing.pace(value), index)
         test(-1, 0)
         test(0, 1)
         test(1, 2)
--- ./test/myotest/deps.py	(original)
+++ ./test/myotest/deps.py	(refactored)
@@ -61,7 +61,7 @@
         """
         # If a string lhs is given, interpret it as a variable name and get
         # the lhs of its defining equation
-        if type(key) in (str, unicode):
+        if type(key) in (str, str):
             key = self.m.get(key)
             if isinstance(key, myokit.Variable):
                 key = key.lhs()
@@ -69,7 +69,7 @@
         # convert it to a Name. Ensure no duplicates are given.
         deps = list(set(deps))
         for k, dep in enumerate(deps):
-            if type(dep) in (str, unicode):
+            if type(dep) in (str, str):
                 deps[k] = self.n(dep)
         # Get dep map
         self.assertIn(key, depmap)
@@ -77,18 +77,18 @@
         # Show what will be tested
         if self.verbose:
             if deps:
-                print('Testing if ' + repr(key) + ' has ')
-                print('  [' + ', '.join([repr(d) for d in deps]) + ']')
+                print(('Testing if ' + repr(key) + ' has '))
+                print(('  [' + ', '.join([repr(d) for d in deps]) + ']'))
                 print('It has:')
-                print('  [' + ', '.join([repr(d) for d in dmap]) + ']')
+                print(('  [' + ', '.join([repr(d) for d in dmap]) + ']'))
             else:
                 if isinstance(key, myokit.Expression):
                     if lhs.var().is_state():
-                        print(repr(key) + ' is a state')
+                        print((repr(key) + ' is a state'))
                     else:
-                        print(repr(key) + ' is a constant')
+                        print((repr(key) + ' is a constant'))
                 else:
-                    print(repr(key) + ' is empty')
+                    print((repr(key) + ' is empty'))
         # Check all dependencies
         for dep in deps:
             self.assertIn(dep, dmap)
@@ -118,16 +118,16 @@
         # Show what was tested
         if self.verbose:
             if deps:
-                print(comp.name() + ' has deps ('
-                    + ', '.join([d.name() for d in deps]) + ')')
+                print((comp.name() + ' has deps ('
+                    + ', '.join([d.name() for d in deps]) + ')'))
             else:
-                print(comp.name() + ' has no dependencies')
+                print((comp.name() + ' has no dependencies'))
 
     def head(self,text):
         if self.verbose:
             x = int((68 - len(text)) / 2)
             y = 68 - len(text) - x
-            print('.'*y + ' ' + text + ' ' + '.'*x)
+            print(('.'*y + ' ' + text + ' ' + '.'*x))
 
 
 class BasicReferenceTest(DepTest):
@@ -146,7 +146,7 @@
         r = myokit.Plus(myokit.Number(5), dy)
         r = r.references()
         self.assertEqual(len(r), 1)
-        r = iter(r).next()
+        r = next(iter(r))
         self.assertEqual(r, dy)
         # Test in parsed model
         d = self.d
@@ -422,7 +422,7 @@
         def has(lhs, *deps):
             return self.has_lhs(depmap, lhs, *deps)
         def nhas(lhs):
-            if type(lhs) in (str, unicode):
+            if type(lhs) in (str, str):
                 lhs = self.m.get(lhs).lhs()
             self.assertNotIn(lhs, depmap)
         # Start testing
@@ -556,7 +556,7 @@
         def has(lhs, *deps):
             return self.has_lhs(depmap, lhs, *deps)
         def nhas(lhs):
-            if type(lhs) in (str, unicode):
+            if type(lhs) in (str, str):
                 lhs = self.m.get(lhs).lhs()
             self.assertNotIn(lhs, depmap)
         # Start testing
@@ -1205,9 +1205,9 @@
                         if i1: break
                 if self.verbose:
                     if i1 < i2:
-                        print(lhs1, 'occurs before', lhs2)
+                        print((lhs1, 'occurs before', lhs2))
                     else:
-                        print(lhs1, 'does NOT occur before', lhs2)
+                        print((lhs1, 'does NOT occur before', lhs2))
                 self.assertLess(i1, i2)
 
         def cbefore(c1, *c2s):
@@ -1223,14 +1223,14 @@
                         if i1: break
                 if self.verbose:
                     if i1 < i2:
-                        print(c1, 'occurs before', c2)
+                        print((c1, 'occurs before', c2))
                     else:
-                        print(c1, 'does NOT occur before', c2)
+                        print((c1, 'does NOT occur before', c2))
                 self.assertLess(i1, i2)
 
         # Start
         # Run multiple times because ordering is slightly random.
-        for i in xrange(0, 5):
+        for i in range(0, 5):
             # Load model, get order
             self.m = myokit.load_model(
                 os.path.join(myotest.DIR_DATA, 'lr-1991-dep.mmt'))
@@ -1344,9 +1344,9 @@
                         if i1: break
                 if self.verbose:
                     if i1 < i2:
-                        print(lhs1, 'occurs before', lhs2)
+                        print((lhs1, 'occurs before', lhs2))
                     else:
-                        print(lhs1, 'does NOT occur before', lhs2)
+                        print((lhs1, 'does NOT occur before', lhs2))
                 self.assertLess(i1, i2)
 
         def cbefore(c1, *c2s):
@@ -1362,14 +1362,14 @@
                         if i1: break
                 if self.verbose:
                     if i1 < i2:
-                        print(c1, 'occurs before', c2)
+                        print((c1, 'occurs before', c2))
                     else:
-                        print(c1, 'does NOT occur before', c2)
+                        print((c1, 'does NOT occur before', c2))
                 self.assertLess(i1, i2)
 
         # Start
         # Run multiple times because ordering is slightly random.
-        for i in xrange(0, 1):
+        for i in range(0, 1):
             # Load model, get order
             self.m = myokit.load_model(
                 os.path.join(myotest.DIR_DATA, 'lr-1991.mmt'))
--- ./test/myotest/simulation.py	(original)
+++ ./test/myotest/simulation.py	(refactored)
@@ -7,7 +7,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import print_function
+
 import myokit
 import myotest
 import os
@@ -71,7 +71,7 @@
         self.assertEqual(type(d), myokit.DataLog)
         self.assertIn('engine.time', d)
         n = len(d['engine.time'])
-        for k,v in d.iteritems():
+        for k,v in d.items():
             self.assertEqual(n, len(v))
 
     def no_protocol(self):
@@ -124,14 +124,14 @@
         n = 4
         s = myokit.Simulation1d(m, p, n)
         sm = m.state()
-        ss = [s.state(x) for x in xrange(n)]
+        ss = [s.state(x) for x in range(n)]
         for si in ss:
             self.assertEqual(sm, si)
         # Test setting a single, global state
         sx = [0] * 8
         self.assertNotEqual(sm, sx)
         s.set_state(sx)
-        for i in xrange(n):
+        for i in range(n):
             self.assertEqual(sx, s.state(i))
         self.assertEqual(sx * n, s.state())
         s.set_state(sm)
@@ -139,7 +139,7 @@
         # Test setting a single state
         j = 1
         s.set_state(sx, j)
-        for i in xrange(n):
+        for i in range(n):
             if i == j:
                 self.assertEqual(s.state(i), sx)
             else:
@@ -155,14 +155,14 @@
         n = 10
         s = myokit.SimulationOpenCL(m, p, n)
         sm = m.state()
-        ss = [s.state(x) for x in xrange(n)]
+        ss = [s.state(x) for x in range(n)]
         for si in ss:
             self.assertEqual(sm, si)
         # Test setting a single, global state
         sx = [0.0] * 8
         self.assertNotEqual(sm, sx)
         s.set_state(sx)
-        for i in xrange(n):
+        for i in range(n):
             self.assertEqual(sx, s.state(i))
         self.assertEqual(sx * n, s.state())
         s.set_state(sm)
@@ -170,7 +170,7 @@
         # Test setting a single state
         j = 1
         s.set_state(sx, j)
-        for i in xrange(n):
+        for i in range(n):
             if i == j:
                 self.assertEqual(s.state(i), sx)
             else:
--- ./test/myotest/datalog.py	(original)
+++ ./test/myotest/datalog.py	(refactored)
@@ -184,7 +184,7 @@
         # Create an irregular time array
         from random import random
         t = []
-        for i in xrange(0, 100):
+        for i in range(0, 100):
             t.append(5 * random())
         t.sort()
         t = np.array(t)
@@ -1143,7 +1143,7 @@
         def split(value):
             s1, s2 = x.split(value)
             return list(s1[var1]),list(s2[var1]),list(s1[var2]),list(s2[var2])
-        for i in xrange(2):
+        for i in range(2):
             # First without, then with numpy
             t1, t2, v1, v2 = split(-5)
             self.assertEqual(t1, [])
--- ./test/myotest/parser.py	(original)
+++ ./test/myotest/parser.py	(refactored)
@@ -43,15 +43,15 @@
         import myokit._parser as p
         from myokit._parser import Tokenizer
         s = Tokenizer('5')
-        self.assertEqual(s.next(), (p.INTEGER, '5', 1, 0))
+        self.assertEqual(next(s), (p.INTEGER, '5', 1, 0))
         s = Tokenizer('3.0')
-        self.assertEqual(s.next(), (p.FLOAT, '3.0', 1, 0))
+        self.assertEqual(next(s), (p.FLOAT, '3.0', 1, 0))
         s = Tokenizer('3.')
-        self.assertEqual(s.next(), (p.FLOAT, '3.', 1, 0))
+        self.assertEqual(next(s), (p.FLOAT, '3.', 1, 0))
         s = Tokenizer('3.E0')
-        self.assertEqual(s.next(), (p.FLOAT, '3.E0', 1, 0))
+        self.assertEqual(next(s), (p.FLOAT, '3.E0', 1, 0))
         s = Tokenizer('.30')
-        self.assertEqual(s.next(), (p.FLOAT, '.30', 1, 0))
+        self.assertEqual(next(s), (p.FLOAT, '.30', 1, 0))
 
 
 class PhasedParseTest(unittest.TestCase):
@@ -251,11 +251,11 @@
         m.set_state(values)
         for k, eq in enumerate(m.inits()):
             self.assertEqual(eq.rhs.eval(), values[k])
-        s = dict(zip(states, values))
+        s = dict(list(zip(states, values)))
         m.set_state(s)
         for k, eq in enumerate(m.inits()):
             self.assertEqual(eq.rhs.eval(), values[k])
-        s = '\n'.join([str(a) + '=' + str(b) for a,b in s.iteritems()])
+        s = '\n'.join([str(a) + '=' + str(b) for a,b in s.items()])
         m.set_state(s)
         for k, eq in enumerate(m.inits()):
             self.assertEqual(eq.rhs.eval(), values[k])
@@ -266,8 +266,8 @@
             s = m.code(line_numbers=True)
             print('\n')
             print(s)
-            print('-'*80)
-            print(myokit.format_parse_error(e, s.splitlines()))
+            print(('-'*80))
+            print((myokit.format_parse_error(e, s.splitlines())))
             raise e
         self.assertEqual(m.code(), m2.code())
     def test_piecewise(self):
--- ./test/myotest/simulation_log_interval.py	(original)
+++ ./test/myotest/simulation_log_interval.py	(refactored)
@@ -7,7 +7,7 @@
 #  Licensed under the GNU General Public License v3.0
 #  See: http://myokit.org
 #
-from __future__ import print_function
+
 import myokit
 import myotest
 import os
