[[model]]
name: Beattie-2017-IKr-HH-Traditional-protocols
author: Michael Clerx
# Initial values
ikr.open = 0
ikr.active = 1

#
# Simulation engine variables
#
[engine]
time = 0 bind time
pace = 0 bind pace

#
# Membrane potential
#
[membrane]
V = engine.pace
    desc: membane potential
    in [mV]

[nernst]
EK = -85 [mV]

[ikr]
use membrane.V
IKr = g * open * active * (V - nernst.EK)
g = p9
dot(open) = (inf - open) / tau
    inf = k1 * tau
    tau = 1 / (k1 + k2)
    k1 = p1 * exp(p2 * V)
    k2 = p3 * exp(-p4 * V)
dot(active) = (inf - active) / tau
    inf = k4 * tau
    tau = 1 / (k3 + k4)
    k3 = p5 * exp(p6 * V)
    k4 = p7 * exp(-p8 * V)
#p1 = 2.26e-4 [1/ms]
#p2 = 0.0699 [1/mV]
#p3 = 3.45e-5 [1/ms]
#p4 = 0.05462 [1/mV]
#p5 = 0.0873 [1/ms]
#p6 = 8.91e-3 [1/mV]
#p7 = 5.15e-3 [1/ms]
#p8 = 0.03158 [1/mV]
#p9 = 0.1524 [mS/uF]
# Traditional fitting result
p1 = 2.36438693119959433e-04
p2 = 7.56312197007569520e-02
p3 = 3.31316724688149562e-06
p4 = 7.39118986028593772e-02
p5 = 9.25523604719411391e-02
p6 = 8.50825588746338679e-03
p7 = 6.64751696075031873e-03
p8 = 3.09841982260208766e-02
p9 = 1.29238129115369027e-01

[[protocol]]
# Level Start   Length  Period  Multiplier
-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
0       next    3       0       0
-120    next    2500    0       0
-80     next    1997    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
0       next    10      0       0
-120    next    2500    0       0
-80     next    1990    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
0       next    30      0       0
-120    next    2500    0       0
-80     next    1970    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
0       next    100     0       0
-120    next    2500    0       0
-80     next    1900    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
0       next    300     0       0
-120    next    2500    0       0
-80     next    1700    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
0       next    1000    0       0
-120    next    2500    0       0
-80     next    1000    0       0

[[script]]
import myokit
import numpy as np
import matplotlib
import matplotlib.gridspec
import matplotlib.pyplot as plt

m = get_model()
p = get_protocol()
s = myokit.Simulation(m, p)

d = s.run(p.characteristic_time())

# Plot data directly
plt.figure(figsize=(12,8))

grid = (4, 1)
matplotlib.gridspec.GridSpec(*grid)

plt.subplot2grid(grid, (0, 0))
plt.ylabel('V (mV)')
plt.plot(d.time(), d['membrane.V'], color='tab:green')

plt.subplot2grid(grid, (1, 0))
plt.ylabel('I (nA)')
plt.plot(d.time(), d['ikr.IKr'], color='tab:blue')

plt.subplot2grid(grid, (2, 0), rowspan=2)
plt.xlabel('Time (ms)')
plt.ylabel('-')
plt.plot(d.time(), d['ikr.open'], '-', label='open', color='tab:orange')
plt.plot(d.time(), d['ikr.active'], '--', label='active', color='tab:gray')
plt.legend()


# Plot data as overlapping steps
dt = 0.5
n = 6
d2 = d.npview()
d2 = d2.regularize(dt)
d2 = d2.fold(5000)

cmap = plt.cm.get_cmap('viridis')
norm = matplotlib.colors.Normalize(0, n)

plt.figure(figsize=(12,8))
plt.suptitle('Pr1 (tidied)')

grid = (5, 1)
matplotlib.gridspec.GridSpec(*grid)

plt.subplot2grid(grid, (0, 0))
plt.ylabel('V (mV)')
plt.xlim(450, 1550)
for k in range(n):
    plt.plot(d2.time(), d2['membrane.V', k], color=cmap(norm(k)))

plt.subplot2grid(grid, (1, 0), rowspan=2)
plt.ylabel('I (nA)')
plt.xlim(450, 1550)
for k in range(n):
    plt.plot(d2.time(), d2['ikr.IKr', k], color=cmap(norm(k)))

plt.subplot2grid(grid, (3, 0), rowspan=2)
plt.xlabel('Time (ms)')
plt.ylabel('States (-)')
plt.xlim(450, 1550)
label1 = 'open/closed'
label2 = 'active/inactive'
for k in range(n):
    plt.plot(d2.time(), d2['ikr.open', k], '-', color=cmap(norm(k)),
             label=label1)
    plt.plot(d2.time(), d2['ikr.active', k], '--', color=cmap(norm(k)),
             label=label2)
    label1 = label2 = None
plt.legend()
plt.tight_layout()

#
# Figure: Peak current vs step duration
#
plt.figure()
plt.xlim(450, 1550)
steps = [3, 10, 30, 100, 300, 1000]
imaxs = []
for k, step in enumerate(steps):
    i1 = 1 + int(500 / dt)
    i2 = i1 + int(step / dt)
    plt.plot(d2.time(), d2['ikr.IKr', k] + k)
    plt.plot(d2.time()[i1:i2], d2['ikr.IKr', k][i1:i2] + k, 'x-')
    
    imaxs.append(d2['ikr.IKr', k][i2 - 1])

plt.figure()
plt.xlabel('Step duration [ms]')
plt.ylabel('Peak current [nA]')
plt.plot(steps, imaxs)
print(imaxs)

# Show all
plt.show()

