[[model]]
name: Beattie-2017-IKr-HH-Traditional-protocols
author: Michael Clerx
# Initial values
ikr.xr1 = 0
ikr.xr2 = 1

#
# Simulation engine variables
#
[engine]
time = 0 bind time
pace = 0 bind pace

#
# Membrane potential
#
[membrane]
V = engine.pace
    desc: membane potential
    in [mV]

[nernst]
EK = -85 [mV]

[ikr]
use membrane.V
Ko = 4.5 [mM]
gKr = 0.153 [mS/uF]
IKr = gKr * sqrt(Ko / 5.4) * xr1 * xr2 * (V - nernst.EK)
    in [A/F]
dot(xr1) = (inf - xr1) / tau
    alpha = 450 / (1 + exp((-45 - V) / 10))    
    beta = 6 / (1 + exp((V + 30) / 11.5))
    tau = 1 * alpha * beta
    inf = 1 / (1 + exp((-26 - V) / 7))
dot(xr2) = (inf - xr2) / tau
    alpha = 3 / (1 + exp((-60 - V) / 20))
    beta = 1.12 / (1 + exp((V - 60) / 20))
    tau = 1 [ms] * alpha * beta
    inf = 1 / (1 + exp((V + 88) / 24))

[[protocol]]
# Level Start   Length  Period  Multiplier
-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
-60     next    5000    0       0
-40     next    1000    0       0
-120    next    500     0       0
-80     next    1000    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
-40     next    5000    0       0
-40     next    1000    0       0
-120    next    500     0       0
-80     next    1000    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
-20     next    5000    0       0
-40     next    1000    0       0
-120    next    500     0       0
-80     next    1000    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
0       next    5000    0       0
-40     next    1000    0       0
-120    next    500     0       0
-80     next    1000    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
20      next    5000    0       0
-40     next    1000    0       0
-120    next    500     0       0
-80     next    1000    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
40      next    5000    0       0
-40     next    1000    0       0
-120    next    500     0       0
-80     next    1000    0       0

-80     next    250     0       0
-120    next    50      0       0
-80     next    200     0       0
60      next    5000    0       0
-40     next    1000    0       0
-120    next    500     0       0
-80     next    1000    0       0

[[script]]
import myokit
import numpy as np
import matplotlib
import matplotlib.gridspec
import matplotlib.pyplot as plt

m = get_model()
p = get_protocol()
s = myokit.Simulation(m, p)

d = s.run(p.characteristic_time())

#
# Figure: Plot data directly
#
plt.figure(figsize=(12,8))

grid = (4, 1)
matplotlib.gridspec.GridSpec(*grid)

plt.subplot2grid(grid, (0, 0))
plt.ylabel('V (mV)')
plt.plot(d.time(), d['membrane.V'], color='tab:green')

plt.subplot2grid(grid, (1, 0))
plt.ylabel('I (nA)')
plt.plot(d.time(), d['ikr.IKr'], color='tab:blue')

plt.subplot2grid(grid, (2, 0), rowspan=2)
plt.xlabel('Time (ms)')
plt.ylabel('States (-)')
plt.plot(d.time(), d['ikr.xr1'], '-', label='open', color='tab:orange')
plt.plot(d.time(), d['ikr.xr2'], '--', label='active', color='tab:gray')
plt.legend()

#
# Figure: Plot data as overlapping steps. Also show states
#
n = 7
d2 = d.npview()
d2 = d2.regularize(0.5)
d2 = d2.fold(8000)

cmap = plt.cm.get_cmap('viridis')
norm = matplotlib.colors.Normalize(0, n)

plt.figure(figsize=(12,8))

grid = (5, 2)
matplotlib.gridspec.GridSpec(*grid)

plt.subplot2grid(grid, (0, 0))
plt.xlabel('Time (ms)')
plt.ylabel('V (mV)')
plt.xlim(5250, 6750)
plt.grid(True)
for k in range(n):
    plt.plot(d2.time(), d2['membrane.V', k], color=cmap(norm(k)))

plt.subplot2grid(grid, (1, 0), rowspan=2)
plt.xlabel('Time (ms)')
plt.ylabel('I (nA)')
plt.xlim(5250, 6750)
plt.ylim(-0.1, 1.6)
plt.grid(True)
for k in range(n):
    plt.plot(d2.time(), d2['ikr.IKr', k], color=cmap(norm(k)))

plt.subplot2grid(grid, (3, 0), rowspan=2)
plt.xlabel('Time (ms)')
plt.ylabel('States (-)')
plt.xlim(5250, 6750)
plt.grid(True)
label1 = 'open/closed'
label2 = 'active/inactive'
for k in range(n):
    plt.plot(d2.time(), d2['ikr.xr1', k], '-', color=cmap(norm(k)),
             label=label1)
    plt.plot(d2.time(), d2['ikr.xr2', k], '--', color=cmap(norm(k)),
             label=label2)
    label1 = label2 = None
plt.legend()

plt.subplot2grid(grid, (0, 1))
plt.xlabel('Time (ms)')
plt.ylabel('V (mV)')
plt.xlim(5250, 6750)
plt.grid(True)
for k in range(n):
    plt.plot(d2.time(), d2['membrane.V', k], color=cmap(norm(k)))

plt.subplot2grid(grid, (1, 1), rowspan=2)
plt.xlabel('Time (ms)')
plt.ylabel('Steady state (-)')
plt.xlim(5250, 6750)
plt.grid(True)
label1 = 'open/closed'
label2 = 'active/inactive'
for k in range(n):
    plt.plot(d2.time(), d2['ikr.xr1.inf', k], '-', color=cmap(norm(k)),
             label=label1)
    plt.plot(d2.time(), d2['ikr.xr2.inf', k], '--', color=cmap(norm(k)),
             label=label2)
    label1 = label2 = None
plt.legend()

plt.subplot2grid(grid, (3, 1), rowspan=2)
plt.xlabel('Time (ms)')
plt.ylabel('Time constant (ms)')
plt.xlim(5250, 6750)
plt.grid(True)
label1 = 'open/closed'
label2 = 'active/inactive'
for k in range(n):
    plt.plot(d2.time(), d2['ikr.xr1.tau', k], '-', color=cmap(norm(k)),
             label=label1)
    plt.plot(d2.time(), d2['ikr.xr2.tau', k], '--', color=cmap(norm(k)),
             label=label2)
    label1 = label2 = None
plt.legend()

plt.tight_layout()
plt.show()

